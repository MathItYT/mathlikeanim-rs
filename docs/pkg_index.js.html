<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: pkg/index.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="AnchorsAndHandles.html">AnchorsAndHandles</a></div><div class="sidebar-section-children"><a href="Arc.html">Arc</a></div><div class="sidebar-section-children"><a href="BoundingBox.html">BoundingBox</a></div><div class="sidebar-section-children"><a href="Circle.html">Circle</a></div><div class="sidebar-section-children"><a href="Color.html">Color</a></div><div class="sidebar-section-children"><a href="ColorStop.html">ColorStop</a></div><div class="sidebar-section-children"><a href="CubicBezierTuple.html">CubicBezierTuple</a></div><div class="sidebar-section-children"><a href="EquilateralTriangle.html">EquilateralTriangle</a></div><div class="sidebar-section-children"><a href="FontFace.html">FontFace</a></div><div class="sidebar-section-children"><a href="ImageBitmap.html">ImageBitmap</a></div><div class="sidebar-section-children"><a href="IntegerLerp.html">IntegerLerp</a></div><div class="sidebar-section-children"><a href="Line.html">Line</a></div><div class="sidebar-section-children"><a href="LinearGradient.html">LinearGradient</a></div><div class="sidebar-section-children"><a href="Path2D.html">Path2D</a></div><div class="sidebar-section-children"><a href="Point2D.html">Point2D</a></div><div class="sidebar-section-children"><a href="RadialGradient.html">RadialGradient</a></div><div class="sidebar-section-children"><a href="Rectangle.html">Rectangle</a></div><div class="sidebar-section-children"><a href="RightTriangle.html">RightTriangle</a></div><div class="sidebar-section-children"><a href="Square.html">Square</a></div><div class="sidebar-section-children"><a href="Style.html">Style</a></div><div class="sidebar-section-children"><a href="TransformationMatrix.html">TransformationMatrix</a></div><div class="sidebar-section-children"><a href="Triangle.html">Triangle</a></div><div class="sidebar-section-children"><a href="Typst.html">Typst</a></div><div class="sidebar-section-children"><a href="VectorObject.html">VectorObject</a></div><div class="sidebar-section-children"><a href="VectorObjectBuilder.html">VectorObjectBuilder</a></div><div class="sidebar-section-children"><a href="module.exports.html">exports</a></div><div class="sidebar-section-children"><a href="module.exports.html">exports</a></div><div class="sidebar-section-children"><a href="module.exports.html">exports</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-tutorials"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-Initial tutorials.html">Initial tutorials</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#inverse_lerp">inverse_lerp</a></div><div class="sidebar-section-children"><a href="global.html#lerp">lerp</a></div><div class="sidebar-section-children"><a href="global.html#matrix_product">matrix_product</a></div><div class="sidebar-section-children"><a href="global.html#matrix_product_path">matrix_product_path</a></div><div class="sidebar-section-children"><a href="global.html#play">play</a></div><div class="sidebar-section-children"><a href="global.html#render">render</a></div><div class="sidebar-section-children"><a href="global.html#render">render</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">pkg_index.js</h1></header><article><pre class="prettyprint source lang-js"><code>let wasm;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' &amp;&amp; name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i &lt; length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches &amp;&amp; builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset &lt; len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined &amp;&amp; cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_2.set(idx, obj);
    return idx;
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    for (let i = 0; i &lt; array.length; i++) {
        const add = addToExternrefTable0(array[i]);
        getDataViewMemory0().setUint32(ptr + 4 * i, add, true);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}

let cachedFloat32ArrayMemory0 = null;

function getFloat32ArrayMemory0() {
    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {
        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);
    }
    return cachedFloat32ArrayMemory0;
}

function passArrayF32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4, 4) >>> 0;
    getFloat32ArrayMemory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

let cachedUint32ArrayMemory0 = null;

function getUint32ArrayMemory0() {
    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32ArrayMemory0;
}

function passArray32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4, 4) >>> 0;
    getUint32ArrayMemory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayF32FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i = ptr; i &lt; ptr + 4 * len; i += 4) {
        result.push(wasm.__wbindgen_export_2.get(mem.getUint32(i, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}

function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_2.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
}
/**
 * Multiplies two matrices together.
 * @param {number[]} a - The first matrix to multiply as a flat array.
 * @param {number[]} b - The second matrix to multiply as a flat array.
 * @param {number} a_rows - The number of rows in the first matrix.
 * @param {number} a_columns - The number of columns in the first matrix.
 * @param {number} b_columns - The number of columns in the second matrix.
 * @returns {number[]} The product of the two matrices.
 */
export function matrix_product(a, b, a_rows, a_columns, b_columns) {
    const ptr0 = passArrayF32ToWasm0(a, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArrayF32ToWasm0(b, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.matrix_product(ptr0, len0, ptr1, len1, a_rows, a_columns, b_columns);
    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v3;
}

/**
 * Multiplies a matrix by a path of 2D points, returning a new path.
 * @param {number[]} matrix - The matrix to multiply as a flat array.
 * @param {Path2D} path - The path to multiply.
 * @param {number} a_rows - The number of rows in the first matrix.
 * @param {number} a_columns - The number of columns in the first matrix.
 * @param {number} b_columns - The number of columns in the second matrix.
 * @returns {Path2D} The product of the matrix and the path.
 */
export function matrix_product_path(matrix, path, a_rows, a_columns, b_columns) {
    const ptr0 = passArrayF32ToWasm0(matrix, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(path, Path2D);
    const ret = wasm.matrix_product_path(ptr0, len0, path.__wbg_ptr, a_rows, a_columns, b_columns);
    return Path2D.__wrap(ret);
}

/**
 * Linearly interpolates between two values given a progress value.
 * @param {number} a - The start value.
 * @param {number} b - The end value.
 * @param {number} t - The progress value.
 * @returns {number} The interpolated value.
 */
export function lerp(a, b, t) {
    const ret = wasm.lerp(a, b, t);
    return ret;
}

/**
 * Returns the progress value between two numbers given an interpolated value.
 * @param {number} a - The start value.
 * @param {number} b - The end value.
 * @param {number} value - The value to find the progress of.
 * @returns {number} The progress value.
 */
export function inverse_lerp(a, b, value) {
    const ret = wasm.inverse_lerp(a, b, value);
    return ret;
}

const AnchorsAndHandlesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_anchorsandhandles_free(ptr >>> 0, 1));
/**
 * Start anchors, first control points, second control points, and end anchors of a path.
 */
export class AnchorsAndHandles {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AnchorsAndHandles.prototype);
        obj.__wbg_ptr = ptr;
        AnchorsAndHandlesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AnchorsAndHandlesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_anchorsandhandles_free(ptr, 0);
    }
    /**
     * Creates a new AnchorsAndHandles object.
     * @param {Point2D[]} start_anchors - The start anchors of the path.
     * @param {Point2D[]} first_controls - The first control points of the path.
     * @param {Point2D[]} second_controls - The second control points of the path.
     * @param {Point2D[]} end_anchors - The end anchors of the path.
     */
    constructor(start_anchors, first_controls, second_controls, end_anchors) {
        const ptr0 = passArrayJsValueToWasm0(start_anchors, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(first_controls, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArrayJsValueToWasm0(second_controls, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passArrayJsValueToWasm0(end_anchors, wasm.__wbindgen_malloc);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.anchorsandhandles_new(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        AnchorsAndHandlesFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a AnchorsAndHandles object from a Path2D object.
     * @param {Path2D} path - The path to extract the anchors and handles from.
     * @returns {AnchorsAndHandles} An object containing the start anchors, first control points, second control points, and end anchors of a path.
     */
    static from_path(path) {
        _assertClass(path, Path2D);
        var ptr0 = path.__destroy_into_raw();
        const ret = wasm.anchorsandhandles_from_path(ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AnchorsAndHandles.__wrap(ret[0]);
    }
    /**
     * Returns the start anchors of the path.
     * @returns {Point2D[]} The start anchors of the path.
     */
    get start_anchors() {
        const ret = wasm.anchorsandhandles_start_anchors(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Returns the first control points of the path.
     * @returns {Point2D[]} The first control points of the path.
     */
    get first_controls() {
        const ret = wasm.anchorsandhandles_first_controls(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Returns the second control points of the path.
     * @returns {Point2D[]} The second control points of the path.
     */
    get second_controls() {
        const ret = wasm.anchorsandhandles_second_controls(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Returns the end anchors of the path.
     * @returns {Point2D[]} The end anchors of the path.
     */
    get end_anchors() {
        const ret = wasm.anchorsandhandles_end_anchors(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Returns the number of cubic bezier curves in the path.
     * @returns {number} The number of cubic bezier curves in the path.
     */
    get len() {
        const ret = wasm.anchorsandhandles_len(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const ArcFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_arc_free(ptr >>> 0, 1));
/**
 * An Arc is a portion of the circumference of a circle.
 */
export class Arc {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Arc.prototype);
        obj.__wbg_ptr = ptr;
        ArcFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ArcFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_arc_free(ptr, 0);
    }
    /**
     * Creates a new Arc object from a center point, radius, start angle, and end angle.
     * @param {Point2D} center - The center point of the arc as a Point2D.
     * @param {number} radius - The radius of the arc.
     * @param {number} start_angle - The start angle of the arc in radians.
     * @param {number} end_angle - The end angle of the arc in radians.
     */
    constructor(center, radius, start_angle, end_angle) {
        _assertClass(center, Point2D);
        var ptr0 = center.__destroy_into_raw();
        const ret = wasm.arc_new(ptr0, radius, start_angle, end_angle);
        this.__wbg_ptr = ret >>> 0;
        ArcFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a new vector object builder with the arc's points.
     * @param {number | null} [samples]
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the arc.
     */
    vector_object_builder(samples) {
        const ret = wasm.arc_vector_object_builder(this.__wbg_ptr, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the center point of the arc.
     * @returns {Point2D} The center point of the arc as a Point2D.
     */
    get center() {
        const ret = wasm.arc_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the radius of the arc.
     * @returns {number} The radius of the arc.
     */
    get radius() {
        const ret = wasm.arc_radius(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the start angle of the arc in radians.
     * @returns {number} The start angle of the arc in radians.
     */
    get start_angle() {
        const ret = wasm.arc_start_angle(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the end angle of the arc in radians.
     * @returns {number} The end angle of the arc in radians.
     */
    get end_angle() {
        const ret = wasm.arc_end_angle(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns a VectorObjectBuilder representing the arc and a tip at the start of the arc.
     * @param {VectorObjectBuilder} tip_shape - The tip shape as a VectorObjectBuilder to add to the start of the arc. It must be pointing to the right and centered at (0, 0). This function will rotate and move it to the correct angle.
     * @param {number | null} [samples] - The number of samples to use to create the arc, by default 15.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the arc and a tip at the start of the arc.
     */
    start_tip_vector_object_builder(tip_shape, samples) {
        _assertClass(tip_shape, VectorObjectBuilder);
        var ptr0 = tip_shape.__destroy_into_raw();
        const ret = wasm.arc_start_tip_vector_object_builder(this.__wbg_ptr, ptr0, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns a VectorObjectBuilder representing the arc and a tip at the end of the arc.
     * @param {VectorObjectBuilder} tip_shape - The tip shape as a VectorObjectBuilder to add to the end of the arc. It must be pointing to the right and centered at (0, 0). This function will rotate and move it to the correct angle.
     * @param {number | null} [samples] - The number of samples to use to create the arc.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the arc and a tip at the end of the arc.
     */
    end_tip_vector_object_builder(tip_shape, samples) {
        _assertClass(tip_shape, VectorObjectBuilder);
        var ptr0 = tip_shape.__destroy_into_raw();
        const ret = wasm.arc_end_tip_vector_object_builder(this.__wbg_ptr, ptr0, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns a VectorObjectBuilder representing the arc and tips at both ends of the arc.
     * @param {VectorObjectBuilder} tip_shape - The tip shape as a VectorObjectBuilder to add to the start of the arc. It must be pointing to the right and centered at (0, 0). This function will rotate and move it to the correct angle.
     * @param {number | null} [samples] - The number of samples to use to create the arc.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the arc and tips at both ends of the arc.
     */
    both_tips_vector_object_builder(tip_shape, samples) {
        _assertClass(tip_shape, VectorObjectBuilder);
        var ptr0 = tip_shape.__destroy_into_raw();
        const ret = wasm.arc_both_tips_vector_object_builder(this.__wbg_ptr, ptr0, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the point on the arc at a given t progress value.
     * @param {number} t - The t value to evaluate the polynomial at. A number between 0 and 1.
     * @returns {Point2D} The Point2D on the arc at the given t value.
     */
    point_at(t) {
        const ret = wasm.arc_point_at(this.__wbg_ptr, t);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the length of the arc.
     * @returns {number} The length of the arc.
     */
    length() {
        const ret = wasm.arc_length(this.__wbg_ptr);
        return ret;
    }
}

const BoundingBoxFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_boundingbox_free(ptr >>> 0, 1));
/**
 * A bounding box is a rectangle that contains a set of points.
 */
export class BoundingBox {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BoundingBox.prototype);
        obj.__wbg_ptr = ptr;
        BoundingBoxFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BoundingBoxFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_boundingbox_free(ptr, 0);
    }
    /**
     * Creates a new bounding box from a minimum x-coordinate, minimum y-coordinate, width, and height.
     * @param {number} min_x - The minimum x-coordinate of the bounding box.
     * @param {number} min_y - The minimum y-coordinate of the bounding box.
     * @param {number} width - The width of the bounding box.
     * @param {number} height - The height of the bounding box.
     */
    constructor(min_x, min_y, width, height) {
        const ret = wasm.boundingbox_new(min_x, min_y, width, height);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        BoundingBoxFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates the instance of a path's bounding box.
     * @param {Path2D} path - The path to calculate the bounding box of.
     * @returns {BoundingBox | undefined} The bounding box of the path.
     */
    static from_path(path) {
        _assertClass(path, Path2D);
        const ret = wasm.boundingbox_from_path(path.__wbg_ptr);
        return ret === 0 ? undefined : BoundingBox.__wrap(ret);
    }
    /**
     * Gets the minimum x-coordinate of the bounding box.
     * @returns {number} The minimum x-coordinate of the bounding box.
     */
    get min_x() {
        const ret = wasm.boundingbox_min_x(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the minimum y-coordinate of the bounding box.
     * @returns {number} The minimum y-coordinate of the bounding box.
     */
    get min_y() {
        const ret = wasm.boundingbox_min_y(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the width of the bounding box.
     * @returns {number} The width of the bounding box.
     */
    get width() {
        const ret = wasm.arc_radius(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the height of the bounding box.
     * @returns {number} The height of the bounding box.
     */
    get height() {
        const ret = wasm.arc_start_angle(this.__wbg_ptr);
        return ret;
    }
    /**
     * Checks if a point is contained within the bounding box.
     * @param {Point2D} point - The point to check if it is contained within the bounding box.
     * @returns {boolean} A boolean indicating if the point is contained within the bounding box.
     */
    contains(point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.boundingbox_contains(this.__wbg_ptr, ptr0);
        return ret !== 0;
    }
    /**
     * Checks if the bounding box overlaps with another bounding box.
     * @param {BoundingBox} other - The other bounding box to check for intersection.
     * @returns {boolean} A boolean indicating if the bounding box overlaps with the other bounding box.
     */
    intersects(other) {
        _assertClass(other, BoundingBox);
        const ret = wasm.boundingbox_intersects(this.__wbg_ptr, other.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Returns the intersection of the bounding box with another bounding box, it means the area that is common to both bounding boxes.
     * @param {BoundingBox | null} [_this] - The bounding box to intersect with.
     * @param {BoundingBox | null} [other] - The other bounding box to intersect with.
     * @returns {BoundingBox | undefined} The intersection of the bounding box with the other bounding box.
     */
    static intersection(_this, other) {
        let ptr0 = 0;
        if (!isLikeNone(_this)) {
            _assertClass(_this, BoundingBox);
            ptr0 = _this.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(other)) {
            _assertClass(other, BoundingBox);
            ptr1 = other.__destroy_into_raw();
        }
        const ret = wasm.boundingbox_intersection(ptr0, ptr1);
        return ret === 0 ? undefined : BoundingBox.__wrap(ret);
    }
    /**
     * Returns the union of the bounding box with another bounding box, it means the smallest bounding box that contains both bounding boxes.
     * @param {BoundingBox | null} [_this] - The bounding box to union with.
     * @param {BoundingBox | null} [other] - The other bounding box to union with.
     * @returns {BoundingBox | undefined} The union of the bounding box with the other bounding box.
     */
    static union(_this, other) {
        let ptr0 = 0;
        if (!isLikeNone(_this)) {
            _assertClass(_this, BoundingBox);
            ptr0 = _this.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(other)) {
            _assertClass(other, BoundingBox);
            ptr1 = other.__destroy_into_raw();
        }
        const ret = wasm.boundingbox_union(ptr0, ptr1);
        return ret === 0 ? undefined : BoundingBox.__wrap(ret);
    }
    /**
     * Returns the center point of the bounding box.
     * @returns {Point2D} The center of the bounding box.
     */
    get center() {
        const ret = wasm.boundingbox_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
}

const CircleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_circle_free(ptr >>> 0, 1));
/**
 * A Circle is a set of all points in a plane that are at a given distance from a given point, the center.
 */
export class Circle {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CircleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_circle_free(ptr, 0);
    }
    /**
     * Creates a new Circle from a center Point2D and a radius.
     * @param {Point2D} center - The center point of the circle as a Point2D.
     * @param {number} radius - The radius of the circle.
     */
    constructor(center, radius) {
        _assertClass(center, Point2D);
        var ptr0 = center.__destroy_into_raw();
        const ret = wasm.circle_new(ptr0, radius);
        this.__wbg_ptr = ret >>> 0;
        CircleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates an Arc from the circle.
     * @returns {Arc} An Arc representing the circle.
     */
    get arc() {
        const ret = wasm.circle_arc(this.__wbg_ptr);
        return Arc.__wrap(ret);
    }
    /**
     * Creates a new VectorObjectBuilder from the circle.
     * @param {number | null} [samples] - The number of samples to use to create the circle, by default 15.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the circle.
     */
    vector_object_builder(samples) {
        const ret = wasm.circle_vector_object_builder(this.__wbg_ptr, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the center point of the circle as a Point2D.
     * @returns {Point2D} The center point of the circle.
     */
    get center() {
        const ret = wasm.arc_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the radius of the circle.
     * @returns {number} The radius of the circle.
     */
    get radius() {
        const ret = wasm.arc_radius(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the circumference of the circle.
     * @returns {number} The circumference of the circle.
     */
    circumference() {
        const ret = wasm.circle_circumference(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the area of the circle.
     * @returns {number} The area of the circle.
     */
    area() {
        const ret = wasm.circle_area(this.__wbg_ptr);
        return ret;
    }
}

const ColorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_color_free(ptr >>> 0, 1));
/**
 * A color with red, green, blue, and alpha components.
 */
export class Color {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Color.prototype);
        obj.__wbg_ptr = ptr;
        ColorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ColorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_color_free(ptr, 0);
    }
    /**
     * The red component of the color.
     * @returns {number}
     */
    get red() {
        const ret = wasm.__wbg_get_color_red(this.__wbg_ptr);
        return ret;
    }
    /**
     * The red component of the color.
     * @param {number} arg0
     */
    set red(arg0) {
        wasm.__wbg_set_color_red(this.__wbg_ptr, arg0);
    }
    /**
     * The green component of the color.
     * @returns {number}
     */
    get green() {
        const ret = wasm.__wbg_get_color_green(this.__wbg_ptr);
        return ret;
    }
    /**
     * The green component of the color.
     * @param {number} arg0
     */
    set green(arg0) {
        wasm.__wbg_set_color_green(this.__wbg_ptr, arg0);
    }
    /**
     * The blue component of the color.
     * @returns {number}
     */
    get blue() {
        const ret = wasm.__wbg_get_color_blue(this.__wbg_ptr);
        return ret;
    }
    /**
     * The blue component of the color.
     * @param {number} arg0
     */
    set blue(arg0) {
        wasm.__wbg_set_color_blue(this.__wbg_ptr, arg0);
    }
    /**
     * The alpha component of the color.
     * @returns {number}
     */
    get alpha() {
        const ret = wasm.__wbg_get_color_alpha(this.__wbg_ptr);
        return ret;
    }
    /**
     * The alpha component of the color.
     * @param {number} arg0
     */
    set alpha(arg0) {
        wasm.__wbg_set_color_alpha(this.__wbg_ptr, arg0);
    }
    /**
     * Creates a new Color with the given red, green, blue, and alpha components.
     * @param {number} red - The red component of the color.
     * @param {number} green - The green component of the color.
     * @param {number} blue - The blue component of the color.
     * @param {number} alpha - The alpha component of the color.
     */
    constructor(red, green, blue, alpha) {
        const ret = wasm.color_new(red, green, blue, alpha);
        this.__wbg_ptr = ret >>> 0;
        ColorFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the default color, which is a fully transparent black.
     * @returns {Color} The default color.
     */
    static default_color() {
        const ret = wasm.color_default_color();
        return Color.__wrap(ret);
    }
    /**
     * Linearly interpolates between two Colors given a progress value.
     * @param {Color} color1 - The start color.
     * @param {Color} color2 - The end color.
     * @param {number} t - The progress value.
     * @returns {Color}
     */
    static lerp(color1, color2, t) {
        _assertClass(color1, Color);
        _assertClass(color2, Color);
        const ret = wasm.color_lerp(color1.__wbg_ptr, color2.__wbg_ptr, t);
        return Color.__wrap(ret);
    }
}

const ColorStopFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_colorstop_free(ptr >>> 0, 1));
/**
 * A color stop for a gradient with a color and a position.
 */
export class ColorStop {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ColorStop.prototype);
        obj.__wbg_ptr = ptr;
        ColorStopFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof ColorStop)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ColorStopFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_colorstop_free(ptr, 0);
    }
    /**
     * The color of the stop.
     * @returns {Color}
     */
    get color() {
        const ret = wasm.__wbg_get_colorstop_color(this.__wbg_ptr);
        return Color.__wrap(ret);
    }
    /**
     * The color of the stop.
     * @param {Color} arg0
     */
    set color(arg0) {
        _assertClass(arg0, Color);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_colorstop_color(this.__wbg_ptr, ptr0);
    }
    /**
     * The position of the stop.
     * @returns {number}
     */
    get position() {
        const ret = wasm.__wbg_get_colorstop_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * The position of the stop.
     * @param {number} arg0
     */
    set position(arg0) {
        wasm.__wbg_set_colorstop_position(this.__wbg_ptr, arg0);
    }
    /**
     * Creates a new ColorStop with the given color and position.
     * @param {Color} color - The color of the stop.
     * @param {number} position - The position of the stop.
     */
    constructor(color, position) {
        _assertClass(color, Color);
        var ptr0 = color.__destroy_into_raw();
        const ret = wasm.colorstop_new(ptr0, position);
        this.__wbg_ptr = ret >>> 0;
        ColorStopFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
}

const CubicBezierTupleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cubicbeziertuple_free(ptr >>> 0, 1));
/**
 * A cubic bezier curve represented by four points: a start anchor, a first control point, a second control point, and an end anchor.
 */
export class CubicBezierTuple {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CubicBezierTuple.prototype);
        obj.__wbg_ptr = ptr;
        CubicBezierTupleFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CubicBezierTupleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cubicbeziertuple_free(ptr, 0);
    }
    /**
     * Creates a new cubic bezier curve.
     * @param {Point2D} start_anchor - The start anchor of the cubic bezier.
     * @param {Point2D} first_control - The first control point of the cubic bezier.
     * @param {Point2D} second_control - The second control point of the cubic bezier.
     * @param {Point2D} end_anchor - The end anchor of the cubic bezier.
     */
    constructor(start_anchor, first_control, second_control, end_anchor) {
        _assertClass(start_anchor, Point2D);
        var ptr0 = start_anchor.__destroy_into_raw();
        _assertClass(first_control, Point2D);
        var ptr1 = first_control.__destroy_into_raw();
        _assertClass(second_control, Point2D);
        var ptr2 = second_control.__destroy_into_raw();
        _assertClass(end_anchor, Point2D);
        var ptr3 = end_anchor.__destroy_into_raw();
        const ret = wasm.cubicbeziertuple_new(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CubicBezierTupleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a new cubic bezier curve from a line.
     * @param {Point2D} p1 - The start point of the line.
     * @param {Point2D} p2 - The end point of the line.
     * @returns {CubicBezierTuple} The cubic bezier curve representing the line.
     */
    static from_line(p1, p2) {
        _assertClass(p1, Point2D);
        var ptr0 = p1.__destroy_into_raw();
        _assertClass(p2, Point2D);
        var ptr1 = p2.__destroy_into_raw();
        const ret = wasm.cubicbeziertuple_from_line(ptr0, ptr1);
        return CubicBezierTuple.__wrap(ret);
    }
    /**
     * Creates a new cubic bezier curve from a quadratic bezier.
     * @param {Point2D} p1 - The first anchor point of the quadratic bezier.
     * @param {Point2D} p2 - The control point of the quadratic bezier.
     * @param {Point2D} p3 - The second anchor point of the quadratic bezier.
     * @returns {CubicBezierTuple} The cubic bezier curve representing the quadratic bezier.
     */
    static from_quadratic(p1, p2, p3) {
        _assertClass(p1, Point2D);
        var ptr0 = p1.__destroy_into_raw();
        _assertClass(p2, Point2D);
        var ptr1 = p2.__destroy_into_raw();
        _assertClass(p3, Point2D);
        var ptr2 = p3.__destroy_into_raw();
        const ret = wasm.cubicbeziertuple_from_quadratic(ptr0, ptr1, ptr2);
        return CubicBezierTuple.__wrap(ret);
    }
    /**
     * Returns the start anchor of the cubic bezier.
     * @returns {Point2D} The start anchor of the cubic bezier.
     */
    get start_anchor() {
        const ret = wasm.cubicbeziertuple_start_anchor(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the first control point of the cubic bezier.
     * @returns {Point2D} The first control point of the cubic bezier.
     */
    get first_control() {
        const ret = wasm.cubicbeziertuple_first_control(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the second control point of the cubic bezier.
     * @returns {Point2D} The second control point of the cubic bezier.
     */
    get second_control() {
        const ret = wasm.cubicbeziertuple_second_control(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the end anchor of the cubic bezier.
     * @returns {Point2D} The end anchor of the cubic bezier.
     */
    get end_anchor() {
        const ret = wasm.cubicbeziertuple_end_anchor(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the point on the cubic bezier curve at a given t value.
     * @param {number} t - The t value to evaluate the polynomial at. A number between 0 and 1.
     * @returns {Point2D} The point on the cubic bezier curve when the polynomial is evaluated at the given t value.
     */
    point_at(t) {
        const ret = wasm.cubicbeziertuple_point_at(this.__wbg_ptr, t);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns an approximation of the length of the cubic bezier curve, based on sampling points along the curve and an optional extra length to add.
     * @param {number | null} [samples] - The number of samples to take along the curve.
     * @param {number | null} [extra_length] - An optional extra length to add to the approximation.
     * @returns {number}
     */
    length(samples, extra_length) {
        const ret = wasm.cubicbeziertuple_length(this.__wbg_ptr, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0, isLikeNone(extra_length) ? 0x100000001 : Math.fround(extra_length));
        return ret;
    }
}

const EquilateralTriangleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_equilateraltriangle_free(ptr >>> 0, 1));
/**
 * An EquilateralTriangle is a triangle in which all three sides are equal in length.
 */
export class EquilateralTriangle {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EquilateralTriangleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_equilateraltriangle_free(ptr, 0);
    }
    /**
     * Creates a new EquilateralTriangle from a center point and side length.
     * @param {Point2D} center - The center Point2D of the equilateral triangle.
     * @param {number} side_length - The side length of the equilateral triangle.
     * @param {number | null} [rotation] - The rotation of the equilateral triangle, if any.
     */
    constructor(center, side_length, rotation) {
        _assertClass(center, Point2D);
        var ptr0 = center.__destroy_into_raw();
        const ret = wasm.equilateraltriangle_new(ptr0, side_length, isLikeNone(rotation) ? 0x100000001 : Math.fround(rotation));
        this.__wbg_ptr = ret >>> 0;
        EquilateralTriangleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a Triangle from the equilateral triangle.
     * @returns {Triangle} A triangle with the equilateral triangle's vertices.
     */
    get triangle() {
        const ret = wasm.equilateraltriangle_triangle(this.__wbg_ptr);
        return Triangle.__wrap(ret);
    }
    /**
     * Creates a VectorObjectBuilder from the equilateral triangle.
     * @returns {VectorObjectBuilder} A vector object builder with the equilateral triangle's points.
     */
    get vector_object_builder() {
        const ret = wasm.equilateraltriangle_vector_object_builder(this.__wbg_ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the center Point2D of the equilateral triangle.
     * @returns {Point2D} The center point of the equilateral triangle.
     */
    get center() {
        const ret = wasm.equilateraltriangle_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the side length of the equilateral triangle.
     * @returns {number} The side length of the equilateral triangle.
     */
    get side_length() {
        const ret = wasm.equilateraltriangle_side_length(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the area of the equilateral triangle.
     * @returns {number} The area of the equilateral triangle.
     */
    get area() {
        const ret = wasm.equilateraltriangle_area(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the perimeter of the equilateral triangle.
     * @returns {number} The perimeter of the equilateral triangle.
     */
    get perimeter() {
        const ret = wasm.equilateraltriangle_perimeter(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the height of the equilateral triangle.
     * @returns {number} The height of the equilateral triangle.
     */
    get height() {
        const ret = wasm.equilateraltriangle_height(this.__wbg_ptr);
        return ret;
    }
}

const FontFaceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_fontface_free(ptr >>> 0, 1));
/**
 * A FontFace represents a font that can be used for rendering text.
 */
export class FontFace {

    static __unwrap(jsValue) {
        if (!(jsValue instanceof FontFace)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FontFaceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_fontface_free(ptr, 0);
    }
    /**
     * Creates a new FontFace from font data.
     * @param {Uint8Array} data - The data of the font face.
     */
    constructor(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.fontface_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        FontFaceFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the data of the font face.
     * @returns {Uint8Array} The data of the font face.
     */
    get data() {
        const ret = wasm.fontface_data(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const ImageBitmapFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_imagebitmap_free(ptr >>> 0, 1));
/**
 * An image bitmap with pixel data.
 */
export class ImageBitmap {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ImageBitmap.prototype);
        obj.__wbg_ptr = ptr;
        ImageBitmapFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ImageBitmapFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_imagebitmap_free(ptr, 0);
    }
    /**
     * The x coordinate of the bitmap.
     * @returns {number}
     */
    get x() {
        const ret = wasm.__wbg_get_imagebitmap_x(this.__wbg_ptr);
        return ret;
    }
    /**
     * The x coordinate of the bitmap.
     * @param {number} arg0
     */
    set x(arg0) {
        wasm.__wbg_set_imagebitmap_x(this.__wbg_ptr, arg0);
    }
    /**
     * The y coordinate of the bitmap.
     * @returns {number}
     */
    get y() {
        const ret = wasm.__wbg_get_colorstop_position(this.__wbg_ptr);
        return ret;
    }
    /**
     * The y coordinate of the bitmap.
     * @param {number} arg0
     */
    set y(arg0) {
        wasm.__wbg_set_colorstop_position(this.__wbg_ptr, arg0);
    }
    /**
     * The width of the bitmap.
     * @returns {number}
     */
    get width() {
        const ret = wasm.__wbg_get_imagebitmap_width(this.__wbg_ptr);
        return ret;
    }
    /**
     * The width of the bitmap.
     * @param {number} arg0
     */
    set width(arg0) {
        wasm.__wbg_set_imagebitmap_width(this.__wbg_ptr, arg0);
    }
    /**
     * The height of the bitmap.
     * @returns {number}
     */
    get height() {
        const ret = wasm.__wbg_get_imagebitmap_height(this.__wbg_ptr);
        return ret;
    }
    /**
     * The height of the bitmap.
     * @param {number} arg0
     */
    set height(arg0) {
        wasm.__wbg_set_imagebitmap_height(this.__wbg_ptr, arg0);
    }
    /**
     * Creates a new ImageBitmap with the given x, y, width, height, and pixel data.
     * @param {number} x - The x coordinate of the bitmap.
     * @param {number} y - The y coordinate of the bitmap.
     * @param {number} width - The width of the bitmap.
     * @param {number} height - The height of the bitmap.
     * @param {Uint8Array} data - The pixel data of the bitmap.
     */
    constructor(x, y, width, height, data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.imagebitmap_new(x, y, width, height, ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        ImageBitmapFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Gets the pixel data of the bitmap.
     * @returns {Uint8Array} The pixel data of the bitmap.
     */
    get data() {
        const ret = wasm.imagebitmap_data(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * Sets the pixel data of the bitmap.
     * @param {Uint8Array} data - The pixel data of the bitmap.
     */
    set data(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.imagebitmap_set_data(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Returns the default ImageBitmap, which is an empty bitmap.
     * @returns {ImageBitmap} The default image bitmap.
     */
    static default_image_bitmap() {
        const ret = wasm.imagebitmap_default_image_bitmap();
        return ImageBitmap.__wrap(ret);
    }
    /**
     * Gets the color of a Point2D in the bitmap.
     * @param {Point2D} p - The point to get the pixel color at.
     * @returns {Color} The color of the pixel.
     */
    get_pixel(p) {
        _assertClass(p, Point2D);
        var ptr0 = p.__destroy_into_raw();
        const ret = wasm.imagebitmap_get_pixel(this.__wbg_ptr, ptr0);
        return Color.__wrap(ret);
    }
    /**
     * Sets a pixel color at a Point2D in the bitmap.
     * @param {Point2D} p - The point to set the pixel color at.
     * @param {Color} color - The color of the pixel.
     */
    set_pixel(p, color) {
        _assertClass(p, Point2D);
        var ptr0 = p.__destroy_into_raw();
        _assertClass(color, Color);
        wasm.imagebitmap_set_pixel(this.__wbg_ptr, ptr0, color.__wbg_ptr);
    }
    /**
     * Gets a bitmap that is filled with a color.
     * @param {number} x - The x coordinate of the bitmap.
     * @param {number} y - The y coordinate of the bitmap.
     * @param {number} width - The width of the bitmap.
     * @param {number} height - The height of the bitmap.
     * @param {Color} color - The color to fill the bitmap with.
     * @returns {ImageBitmap} The filled image bitmap.
     */
    static fill(x, y, width, height, color) {
        _assertClass(color, Color);
        const ret = wasm.imagebitmap_fill(x, y, width, height, color.__wbg_ptr);
        return ImageBitmap.__wrap(ret);
    }
    /**
     * Gets a bitmap that is filled with a linear gradient.
     * @param {number} x - The x coordinate of the bitmap.
     * @param {number} y - The y coordinate of the bitmap.
     * @param {number} width - The width of the bitmap.
     * @param {number} height - The height of the bitmap.
     * @param {LinearGradient} gradient - The linear gradient to fill the bitmap with.
     * @returns {ImageBitmap} The filled image bitmap.
     */
    static fill_linear_gradient(x, y, width, height, gradient) {
        _assertClass(gradient, LinearGradient);
        const ret = wasm.imagebitmap_fill_linear_gradient(x, y, width, height, gradient.__wbg_ptr);
        return ImageBitmap.__wrap(ret);
    }
    /**
     * Gets a bitmap that is filled with a radial gradient.
     * @param {number} x - The x coordinate of the bitmap.
     * @param {number} y - The y coordinate of the bitmap.
     * @param {number} width - The width of the bitmap.
     * @param {number} height - The height of the bitmap.
     * @param {RadialGradient} gradient - The radial gradient to fill the bitmap with.
     * @returns {ImageBitmap} The filled image bitmap.
     */
    static fill_radial_gradient(x, y, width, height, gradient) {
        _assertClass(gradient, RadialGradient);
        const ret = wasm.imagebitmap_fill_radial_gradient(x, y, width, height, gradient.__wbg_ptr);
        return ImageBitmap.__wrap(ret);
    }
    /**
     * Linearly interpolates between two ImageBitmaps given a progress value.
     * @param {ImageBitmap} bitmap1 - The first image bitmap.
     * @param {ImageBitmap} bitmap2 - The second image bitmap.
     * @param {number} t - The progress value.
     * @returns {ImageBitmap} The interpolated image bitmap.
     */
    static lerp(bitmap1, bitmap2, t) {
        _assertClass(bitmap1, ImageBitmap);
        _assertClass(bitmap2, ImageBitmap);
        const ret = wasm.imagebitmap_lerp(bitmap1.__wbg_ptr, bitmap2.__wbg_ptr, t);
        return ImageBitmap.__wrap(ret);
    }
}

const IntegerLerpFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_integerlerp_free(ptr >>> 0, 1));
/**
 * A variant of lerp that returns the integer index and remainder. Useful for discrete interpolation.
 */
export class IntegerLerp {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IntegerLerpFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_integerlerp_free(ptr, 0);
    }
    /**
     * Interpolates between two values and returns the integer index and remainder.
     * @param {number} a - The start value.
     * @param {number} b - The end value.
     * @param {number} t - The progress value.
     */
    constructor(a, b, t) {
        const ret = wasm.integerlerp_new(a, b, t);
        this.__wbg_ptr = ret >>> 0;
        IntegerLerpFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Gets the integer index.
     * @returns {number} The integer index.
     */
    get index() {
        const ret = wasm.integerlerp_index(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the remainder.
     * @returns {number} The remainder.
     */
    get remainder() {
        const ret = wasm.integerlerp_remainder(this.__wbg_ptr);
        return ret;
    }
}

const LineFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_line_free(ptr >>> 0, 1));
/**
 * A Line is a straight one-dimensional figure that extends infinitely in both directions.
 * It is defined by two points.
 */
export class Line {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Line.prototype);
        obj.__wbg_ptr = ptr;
        LineFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LineFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_line_free(ptr, 0);
    }
    /**
     * The starting point of the line as Point2D.
     * @returns {Point2D}
     */
    get start() {
        const ret = wasm.__wbg_get_line_start(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * The starting point of the line as Point2D.
     * @param {Point2D} arg0
     */
    set start(arg0) {
        _assertClass(arg0, Point2D);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_line_start(this.__wbg_ptr, ptr0);
    }
    /**
     * The ending point of the line as Point2D.
     * @returns {Point2D}
     */
    get end() {
        const ret = wasm.__wbg_get_line_end(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * The ending point of the line as Point2D.
     * @param {Point2D} arg0
     */
    set end(arg0) {
        _assertClass(arg0, Point2D);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_line_end(this.__wbg_ptr, ptr0);
    }
    /**
     * Creates a new Line object from two points.
     * @param {Point2D} start
     * @param {Point2D} end
     */
    constructor(start, end) {
        _assertClass(start, Point2D);
        var ptr0 = start.__destroy_into_raw();
        _assertClass(end, Point2D);
        var ptr1 = end.__destroy_into_raw();
        const ret = wasm.line_new(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        LineFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Gets a VectorObjectBuilder with the line's points.
     * @returns {VectorObjectBuilder} A vector object builder with the line's points.
     */
    get vector_object_builder() {
        const ret = wasm.line_vector_object_builder(this.__wbg_ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the length of the line.
     * @returns {number} The length of the line.
     */
    get length() {
        const ret = wasm.line_length(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the midpoint of the line as a Point2D.
     * @returns {Point2D} The midpoint of the line.
     */
    midpoint() {
        const ret = wasm.line_midpoint(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the slope of the line.
     * @returns {number} The slope of the line.
     */
    slope() {
        const ret = wasm.line_slope(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the y-intercept of the line.
     * @returns {number} The y-intercept of the line.
     */
    y_intercept() {
        const ret = wasm.line_y_intercept(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the normal slope of the line.
     * @returns {number} The normal slope of the line.
     */
    normal_slope() {
        const ret = wasm.line_normal_slope(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the perpendicular line of the line at a given Point2D.
     * @param {Point2D} point - The point to create the perpendicular line at.
     * @returns {Line} The perpendicular line of the line at the given point.
     */
    perpendicular_line(point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.line_perpendicular_line(this.__wbg_ptr, ptr0);
        return Line.__wrap(ret);
    }
    /**
     * Returns the intersection Point2D of the line with another line, if it exists.
     * @param {Line} other - The other line to intersect with.
     * @returns {Point2D | undefined} The intersection point of the two lines if it exists.
     */
    intersection(other) {
        _assertClass(other, Line);
        const ret = wasm.line_intersection(this.__wbg_ptr, other.__wbg_ptr);
        return ret === 0 ? undefined : Point2D.__wrap(ret);
    }
    /**
     * Returns whether the line contains a given Point2D.
     * @param {Point2D} point - The point to check if it is contained.
     * @returns {boolean} Whether the line contains the given point.
     */
    contains(point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.line_contains(this.__wbg_ptr, ptr0);
        return ret !== 0;
    }
    /**
     * Returns the distance from the line to a given Point2D.
     * @param {Point2D} point - The point to calculate the distance to.
     * @returns {number} The distance from the line to the given point.
     */
    distance_to_point(point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.line_distance_to_point(this.__wbg_ptr, ptr0);
        return ret;
    }
    /**
     * Creates a VectorObjectBuilder with the line's points and a tip at the start.
     * @param {VectorObjectBuilder} tip_shape - The shape of the tip. The shape must be pointing to the right and centered to (0, 0), this function will rotate and move it to the correct angle.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder with the line's points and a tip at the start.
     */
    with_tip_at_the_start(tip_shape) {
        _assertClass(tip_shape, VectorObjectBuilder);
        var ptr0 = tip_shape.__destroy_into_raw();
        const ret = wasm.line_with_tip_at_the_start(this.__wbg_ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Creates a VectorObjectBuilder with the line's points and a tip at the end.
     * @param {VectorObjectBuilder} tip_shape - The shape of the tip. The shape must be pointing to the right and centered to (0, 0), this function will rotate and move it to the correct angle.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder with the line's points and a tip at the end.
     */
    with_tip_at_the_end(tip_shape) {
        _assertClass(tip_shape, VectorObjectBuilder);
        var ptr0 = tip_shape.__destroy_into_raw();
        const ret = wasm.line_with_tip_at_the_end(this.__wbg_ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Creates a VectorObjectBuilder with the line's points and tips at both ends.
     * @param {VectorObjectBuilder} tip_shape - The shape of the tip. The shape must be pointing to the right, this function will rotate and move it to the correct angle.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder with the line's points and tips at both ends.
     */
    with_tips_at_both_ends(tip_shape) {
        _assertClass(tip_shape, VectorObjectBuilder);
        var ptr0 = tip_shape.__destroy_into_raw();
        const ret = wasm.line_with_tips_at_both_ends(this.__wbg_ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
}

const LinearGradientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_lineargradient_free(ptr >>> 0, 1));
/**
 * A linear gradient with a start and end point and color stops.
 */
export class LinearGradient {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LinearGradient.prototype);
        obj.__wbg_ptr = ptr;
        LinearGradientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LinearGradientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_lineargradient_free(ptr, 0);
    }
    /**
     * The start point of the gradient.
     * @returns {Point2D}
     */
    get p1() {
        const ret = wasm.__wbg_get_lineargradient_p1(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * The start point of the gradient.
     * @param {Point2D} arg0
     */
    set p1(arg0) {
        _assertClass(arg0, Point2D);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_lineargradient_p1(this.__wbg_ptr, ptr0);
    }
    /**
     * The end point of the gradient.
     * @returns {Point2D}
     */
    get p2() {
        const ret = wasm.__wbg_get_lineargradient_p2(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * The end point of the gradient.
     * @param {Point2D} arg0
     */
    set p2(arg0) {
        _assertClass(arg0, Point2D);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_lineargradient_p2(this.__wbg_ptr, ptr0);
    }
    /**
     * Creates a new LinearGradient with the given start point, end point, and ColorStops.
     * @param {Point2D} p1 - The start point of the gradient.
     * @param {Point2D} p2 - The end point of the gradient.
     * @param {ColorStop[]} color_stops - The color stops of the gradient.
     */
    constructor(p1, p2, color_stops) {
        _assertClass(p1, Point2D);
        var ptr0 = p1.__destroy_into_raw();
        _assertClass(p2, Point2D);
        var ptr1 = p2.__destroy_into_raw();
        const ptr2 = passArrayJsValueToWasm0(color_stops, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        const ret = wasm.lineargradient_new(ptr0, ptr1, ptr2, len2);
        this.__wbg_ptr = ret >>> 0;
        LinearGradientFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the default LinearGradient, which is a gradient from the start to the end the same color.
     * @param {Point2D} p1 - The start point of the gradient.
     * @param {Point2D} p2 - The end point of the gradient.
     * @param {Color} color - The color of the gradient.
     * @returns {LinearGradient} The default linear gradient.
     */
    static single_color_gradient(p1, p2, color) {
        _assertClass(p1, Point2D);
        var ptr0 = p1.__destroy_into_raw();
        _assertClass(p2, Point2D);
        var ptr1 = p2.__destroy_into_raw();
        _assertClass(color, Color);
        var ptr2 = color.__destroy_into_raw();
        const ret = wasm.lineargradient_single_color_gradient(ptr0, ptr1, ptr2);
        return LinearGradient.__wrap(ret);
    }
    /**
     * Returns the default LinearGradient, which is a gradient from the origin to the origin with no ColorStops.
     * @returns {LinearGradient} The default linear gradient.
     */
    static default_linear_gradient() {
        const ret = wasm.lineargradient_default_linear_gradient();
        return LinearGradient.__wrap(ret);
    }
    /**
     * Gets the ColorStops of the gradient.
     * @returns {ColorStop[]} The color stops of the gradient.
     */
    get color_stops() {
        const ret = wasm.lineargradient_color_stops(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Sets the ColorStops of the gradient.
     * @param {ColorStop[]} color_stops - The color stops of the gradient.
     */
    set color_stops(color_stops) {
        const ptr0 = passArrayJsValueToWasm0(color_stops, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.lineargradient_set_color_stops(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Gets the Color at a given offset along the gradient.
     * @param {number} position - The offset to get the color at.
     * @returns {Color} The color at the given offset.
     */
    color_at_offset(position) {
        const ret = wasm.lineargradient_color_at_offset(this.__wbg_ptr, position);
        return Color.__wrap(ret);
    }
    /**
     * Gets the Color at a given point along the gradient.
     * @param {Point2D} p - The point to get the color at.
     * @returns {Color} The color at the given point.
     */
    color_at(p) {
        _assertClass(p, Point2D);
        var ptr0 = p.__destroy_into_raw();
        const ret = wasm.lineargradient_color_at(this.__wbg_ptr, ptr0);
        return Color.__wrap(ret);
    }
    /**
     * Linearly interpolates between two LinearGradients given a progress value.
     * @param {LinearGradient} gradient1 - The first linear gradient.
     * @param {LinearGradient} gradient2 - The second linear gradient.
     * @param {number} t - The progress value.
     * @returns {LinearGradient} The interpolated linear gradient.
     */
    static lerp(gradient1, gradient2, t) {
        _assertClass(gradient1, LinearGradient);
        _assertClass(gradient2, LinearGradient);
        const ret = wasm.lineargradient_lerp(gradient1.__wbg_ptr, gradient2.__wbg_ptr, t);
        return LinearGradient.__wrap(ret);
    }
}

const Path2DFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_path2d_free(ptr >>> 0, 1));
/**
 * A 2D path.
 */
export class Path2D {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Path2D.prototype);
        obj.__wbg_ptr = ptr;
        Path2DFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Path2DFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_path2d_free(ptr, 0);
    }
    /**
     * Creates a new Path2D with the given points.
     * @param {Point2D[]} points - The points of the path.
     */
    constructor(points) {
        const ptr0 = passArrayJsValueToWasm0(points, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.path2d_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        Path2DFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a new Path2D given a AnchorsAndHandles object.
     * @param {AnchorsAndHandles} anchors_and_handles - The AnchorsAndHandles object.
     * @returns {Path2D} A 2D path.
     */
    static from_anchors_and_handles(anchors_and_handles) {
        _assertClass(anchors_and_handles, AnchorsAndHandles);
        const ret = wasm.path2d_from_anchors_and_handles(anchors_and_handles.__wbg_ptr);
        return Path2D.__wrap(ret);
    }
    /**
     * Repeats the Path2D a given number of times.
     * @param {number} count - The number of times to repeat the path.
     * @returns {Path2D} The repeated path.
     */
    repeat(count) {
        const ret = wasm.path2d_repeat(this.__wbg_ptr, count);
        return Path2D.__wrap(ret);
    }
    /**
     * Returns the Point2Ds of the Path2D.
     * @returns {Point2D[]} The points of the path.
     */
    get points() {
        const ret = wasm.path2d_points(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Sets the Point2Ds of the Path2D.
     * @param {Point2D[]} points - The points of the path.
     */
    set points(points) {
        const ptr0 = passArrayJsValueToWasm0(points, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.path2d_set_points(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Returns whether the Path2D is empty.
     * @returns {boolean} A boolean indicating whether the path is empty.
     */
    get is_empty() {
        const ret = wasm.path2d_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Returns the closest Point2D in the Path2D to a given Point2D.
     * @param {Point2D} point - The point to find the closest point to.
     * @returns {Point2D} The closest point in the path.
     */
    closest_point(point) {
        _assertClass(point, Point2D);
        const ret = wasm.path2d_closest_point(this.__wbg_ptr, point.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the length of the Path2D.
     * @returns {number} The length of the path.
     */
    get len() {
        const ret = wasm.path2d_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Returns the Point2D at a given index.
     * @param {number} index - The index of the point.
     * @returns {Point2D} The first point of the path.
     */
    get(index) {
        const ret = wasm.path2d_get(this.__wbg_ptr, index);
        return Point2D.__wrap(ret);
    }
    /**
     * Sets the Point2D at the given index.
     * @param {number} index - The index of the point.
     * @param {Point2D} point - The new point.
     */
    set(index, point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        wasm.path2d_set(this.__wbg_ptr, index, ptr0);
    }
    /**
     * Appends a Point2D to the Path2D.
     * @param {Point2D} point - The point to append.
     */
    push(point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        wasm.path2d_push(this.__wbg_ptr, ptr0);
    }
    /**
     * Removes the last Point2D from the Path2D.
     * @returns {Point2D | undefined} The last point of the path.
     */
    pop() {
        const ret = wasm.path2d_pop(this.__wbg_ptr);
        return ret === 0 ? undefined : Point2D.__wrap(ret);
    }
    /**
     * Inserts a Point2D at a given index.
     * @param {number} index - The index to insert the point at.
     * @param {Point2D} point - The point to insert.
     */
    insert(index, point) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        wasm.path2d_insert(this.__wbg_ptr, index, ptr0);
    }
    /**
     * Removes a Point2D at a given index.
     * @param {number} index - The index of the point to remove.
     * @returns {Point2D} The removed point.
     */
    remove(index) {
        const ret = wasm.path2d_remove(this.__wbg_ptr, index);
        return Point2D.__wrap(ret);
    }
    /**
     * Removes all Point2Ds from the Path2D.
     */
    clear() {
        wasm.path2d_clear(this.__wbg_ptr);
    }
    /**
     * Returns a new Path2D representing a bezier curve portion of the Path2D.
     * @param {number} a - The start proportion of the input path. A number between 0 and 1.
     * @param {number} b - The end proportion of the input path. A number between 0 and 1.
     * @returns {Path2D} A Path2D object representing the portion of the input path.
     */
    partial_bezier_path(a, b) {
        const ret = wasm.path2d_partial_bezier_path(this.__wbg_ptr, a, b);
        return Path2D.__wrap(ret);
    }
    /**
     * Creates a new Path2D by filling the Path2D with a given Point2D a given number of times.
     * @param {Point2D} point - The point to fill the path with.
     * @param {number} count - The number of times to fill the path with the point.
     * @returns {Path2D} A path that is a portion of the input path.
     */
    static fill(point, count) {
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.path2d_fill(ptr0, count);
        return Path2D.__wrap(ret);
    }
    /**
     * Reverse the Path2D.
     */
    reverse() {
        wasm.path2d_reverse(this.__wbg_ptr);
    }
    /**
     * Sets a slice of the Path2D.
     * @param {number} start - The start index of the slice.
     * @param {number} end - The end index of the slice.
     * @param {Path2D} path - The new path.
     */
    set_slice(start, end, path) {
        _assertClass(path, Path2D);
        var ptr0 = path.__destroy_into_raw();
        wasm.path2d_set_slice(this.__wbg_ptr, start, end, ptr0);
    }
    /**
     * Returns a slice of the Path2D
     * @param {number} start - The start index of the slice.
     * @param {number} end - The end index of the slice.
     * @returns {Path2D} A slice of the path.
     */
    slice(start, end) {
        const ret = wasm.path2d_slice(this.__wbg_ptr, start, end);
        return Path2D.__wrap(ret);
    }
    /**
     * Returns a CubicBezierTuple at a given index.
     * @returns {CubicBezierTuple[]} The cubic bezier tuples of the path.
     */
    get cubic_bezier_tuples() {
        const ret = wasm.path2d_cubic_bezier_tuples(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Appends a CubicBezierTuple to the Path2D.
     * @param {CubicBezierTuple} cubic_bezier - The cubic bezier tuple to add.
     */
    push_bezier(cubic_bezier) {
        _assertClass(cubic_bezier, CubicBezierTuple);
        var ptr0 = cubic_bezier.__destroy_into_raw();
        wasm.path2d_push_bezier(this.__wbg_ptr, ptr0);
    }
    /**
     * Returns an approximation of the length of the path, based on sampling points along each cubic bezier curve in the path and an optional extra length to add to each approximation.
     * @param {number | null} [samples_per_cubic] - The number of samples to take along each cubic bezier curve.
     * @param {number | null} [extra_length_per_cubic] - An optional extra length to add to each cubic bezier length approximation.
     * @returns {number} An approximation of the length of the path.
     */
    length(samples_per_cubic, extra_length_per_cubic) {
        const ret = wasm.path2d_length(this.__wbg_ptr, isLikeNone(samples_per_cubic) ? 0x100000001 : (samples_per_cubic) >>> 0, isLikeNone(extra_length_per_cubic) ? 0x100000001 : Math.fround(extra_length_per_cubic));
        return ret;
    }
}

const Point2DFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_point2d_free(ptr >>> 0, 1));
/**
 * A 2D point.
 */
export class Point2D {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Point2D.prototype);
        obj.__wbg_ptr = ptr;
        Point2DFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Point2D)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Point2DFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_point2d_free(ptr, 0);
    }
    /**
     * The x-coordinate of the point.
     * @returns {number}
     */
    get x() {
        const ret = wasm.__wbg_get_point2d_x(this.__wbg_ptr);
        return ret;
    }
    /**
     * The x-coordinate of the point.
     * @param {number} arg0
     */
    set x(arg0) {
        wasm.__wbg_set_point2d_x(this.__wbg_ptr, arg0);
    }
    /**
     * The y-coordinate of the point.
     * @returns {number}
     */
    get y() {
        const ret = wasm.__wbg_get_point2d_y(this.__wbg_ptr);
        return ret;
    }
    /**
     * The y-coordinate of the point.
     * @param {number} arg0
     */
    set y(arg0) {
        wasm.__wbg_set_point2d_y(this.__wbg_ptr, arg0);
    }
    /**
     * Creates a new Point2D with the given coordinates.
     * @param {number} x - The x-coordinate of the point.
     * @param {number} y - The y-coordinate of the point.
     */
    constructor(x, y) {
        const ret = wasm.point2d_new(x, y);
        this.__wbg_ptr = ret >>> 0;
        Point2DFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Linearly interpolates between two Point2D objects.
     * @param {Point2D} point1 - The start point.
     * @param {Point2D} point2 - The end point.
     * @param {number} t - The progress value.
     * @returns {Point2D} The interpolated point.
     */
    static lerp(point1, point2, t) {
        _assertClass(point1, Point2D);
        _assertClass(point2, Point2D);
        const ret = wasm.point2d_lerp(point1.__wbg_ptr, point2.__wbg_ptr, t);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the distance between two Point2Ds.
     * @param {Point2D} other - The other point.
     * @returns {number} The distance between the two points.
     */
    distance_squared(other) {
        _assertClass(other, Point2D);
        const ret = wasm.point2d_distance_squared(this.__wbg_ptr, other.__wbg_ptr);
        return ret;
    }
    /**
     * Checks if two Point2D objects are equal within a given tolerance.
     * @param {Point2D} other - The other point.
     * @param {number | null} [tolerance] - The tolerance.
     * @returns {boolean} A boolean indicating whether the two points are equal.
     */
    equals(other, tolerance) {
        _assertClass(other, Point2D);
        const ret = wasm.point2d_equals(this.__wbg_ptr, other.__wbg_ptr, isLikeNone(tolerance) ? 0x100000001 : Math.fround(tolerance));
        return ret !== 0;
    }
    /**
     * Returns the Point2D rotated around a given center point by a given angle.
     * @param {Point2D} center - The center point to rotate around.
     * @param {number} angle - The angle to rotate by.
     * @returns {Point2D} The rotated point.
     */
    rotate_around(center, angle) {
        _assertClass(center, Point2D);
        var ptr0 = center.__destroy_into_raw();
        const ret = wasm.point2d_rotate_around(this.__wbg_ptr, ptr0, angle);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the distance between two Point2Ds.
     * @param {Point2D} other - The other point.
     * @returns {number} The distance between the two points.
     */
    distance(other) {
        _assertClass(other, Point2D);
        const ret = wasm.point2d_distance(this.__wbg_ptr, other.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the squared magnitude of the Point2D.
     * @returns {number} The squared magnitude of the point.
     */
    get magnitude_squared() {
        const ret = wasm.point2d_magnitude_squared(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the magnitude of the Point2D.
     * @returns {number} The magnitude of the point.
     */
    get magnitude() {
        const ret = wasm.point2d_magnitude(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the normalized Point2D.
     * @returns {Point2D} The normalized point.
     */
    get normalized() {
        const ret = wasm.point2d_normalized(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the dot product of Point2D objects.
     * @param {Point2D} other - The other point.
     * @returns {number} The dot product of the two points.
     */
    dot(other) {
        _assertClass(other, Point2D);
        const ret = wasm.point2d_dot(this.__wbg_ptr, other.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the angle between two Point2Ds.
     * @param {Point2D} other - The other point.
     * @returns {number} The angle between the two points.
     */
    angle(other) {
        _assertClass(other, Point2D);
        const ret = wasm.point2d_angle(this.__wbg_ptr, other.__wbg_ptr);
        return ret;
    }
}

const RadialGradientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_radialgradient_free(ptr >>> 0, 1));
/**
 * A radial gradient with two circles and color stops.
 */
export class RadialGradient {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RadialGradient.prototype);
        obj.__wbg_ptr = ptr;
        RadialGradientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RadialGradientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_radialgradient_free(ptr, 0);
    }
    /**
     * The focal point of the gradient.
     * @returns {Point2D}
     */
    get f() {
        const ret = wasm.__wbg_get_lineargradient_p1(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * The focal point of the gradient.
     * @param {Point2D} arg0
     */
    set f(arg0) {
        _assertClass(arg0, Point2D);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_lineargradient_p1(this.__wbg_ptr, ptr0);
    }
    /**
     * The center point of the gradient.
     * @returns {Point2D}
     */
    get c() {
        const ret = wasm.__wbg_get_lineargradient_p2(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * The center point of the gradient.
     * @param {Point2D} arg0
     */
    set c(arg0) {
        _assertClass(arg0, Point2D);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_lineargradient_p2(this.__wbg_ptr, ptr0);
    }
    /**
     * The radius of the gradient.
     * @returns {number}
     */
    get r() {
        const ret = wasm.__wbg_get_radialgradient_r(this.__wbg_ptr);
        return ret;
    }
    /**
     * The radius of the gradient.
     * @param {number} arg0
     */
    set r(arg0) {
        wasm.__wbg_set_radialgradient_r(this.__wbg_ptr, arg0);
    }
    /**
     * Creates a new RadialGradient with the given focal point, center point, radius, and ColorStops.
     * @param {Point2D} f - The focal point of the gradient.
     * @param {Point2D} c - The center of the gradient.
     * @param {number} r - The radius of the gradient.
     * @param {ColorStop[]} color_stops - The color stops of the gradient.
     */
    constructor(f, c, r, color_stops) {
        _assertClass(f, Point2D);
        var ptr0 = f.__destroy_into_raw();
        _assertClass(c, Point2D);
        var ptr1 = c.__destroy_into_raw();
        const ptr2 = passArrayJsValueToWasm0(color_stops, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        const ret = wasm.radialgradient_new(ptr0, ptr1, r, ptr2, len2);
        this.__wbg_ptr = ret >>> 0;
        RadialGradientFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the default RadialGradient, which is a gradient from the focal point to the center with the same color.
     * @returns {RadialGradient} The default radial gradient.
     */
    static default_radial_gradient() {
        const ret = wasm.radialgradient_default_radial_gradient();
        return RadialGradient.__wrap(ret);
    }
    /**
     * Gets the ColorStops of the gradient.
     * @returns {ColorStop[]} The color stops of the gradient.
     */
    get color_stops() {
        const ret = wasm.radialgradient_color_stops(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Sets the ColorStops of the gradient.
     * @param {ColorStop[]} color_stops - The color stops of the gradient.
     */
    set color_stops(color_stops) {
        const ptr0 = passArrayJsValueToWasm0(color_stops, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.radialgradient_set_color_stops(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Gets the Color at a given offset along the gradient.
     * @param {number} position - The offset to get the color at.
     * @returns {Color} The color at the given offset.
     */
    color_at_offset(position) {
        const ret = wasm.radialgradient_color_at_offset(this.__wbg_ptr, position);
        return Color.__wrap(ret);
    }
    /**
     * Gets the Color at a given point along the gradient.
     * @param {Point2D} p - The point to get the color at.
     * @returns {Color} The color at the given point.
     */
    color_at(p) {
        _assertClass(p, Point2D);
        var ptr0 = p.__destroy_into_raw();
        const ret = wasm.radialgradient_color_at(this.__wbg_ptr, ptr0);
        return Color.__wrap(ret);
    }
    /**
     * Returns a single color radial gradient.
     * @param {Point2D} f - The focal point of the gradient.
     * @param {Point2D} c - The center of the gradient.
     * @param {number} r - The radius of the gradient.
     * @param {Color} color - The color of the gradient.
     * @returns {RadialGradient} A single color radial gradient.
     */
    static single_color_gradient(f, c, r, color) {
        _assertClass(f, Point2D);
        var ptr0 = f.__destroy_into_raw();
        _assertClass(c, Point2D);
        var ptr1 = c.__destroy_into_raw();
        _assertClass(color, Color);
        var ptr2 = color.__destroy_into_raw();
        const ret = wasm.radialgradient_single_color_gradient(ptr0, ptr1, r, ptr2);
        return RadialGradient.__wrap(ret);
    }
    /**
     * Linearly interpolates between two RadialGradients given a progress value.
     * @param {RadialGradient} gradient1 - The first radial gradient.
     * @param {RadialGradient} gradient2 - The second radial gradient.
     * @param {number} t - The progress value.
     * @returns {RadialGradient} The interpolated radial gradient.
     */
    static lerp(gradient1, gradient2, t) {
        _assertClass(gradient1, RadialGradient);
        _assertClass(gradient2, RadialGradient);
        const ret = wasm.radialgradient_lerp(gradient1.__wbg_ptr, gradient2.__wbg_ptr, t);
        return RadialGradient.__wrap(ret);
    }
}

const RectangleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_rectangle_free(ptr >>> 0, 1));
/**
 * A Rectangle is a quadrilateral with four right angles.
 */
export class Rectangle {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Rectangle.prototype);
        obj.__wbg_ptr = ptr;
        RectangleFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RectangleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rectangle_free(ptr, 0);
    }
    /**
     * Creates a new Rectangle from a BoundingBox and an optional rotation.
     * @param {BoundingBox} bbox - The BoundingBox of the rectangle.
     * @param {number | null} [rotation] - The rotation of the rectangle, if any.
     */
    constructor(bbox, rotation) {
        _assertClass(bbox, BoundingBox);
        var ptr0 = bbox.__destroy_into_raw();
        const ret = wasm.rectangle_new(ptr0, isLikeNone(rotation) ? 0x100000001 : Math.fround(rotation));
        this.__wbg_ptr = ret >>> 0;
        RectangleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Gets a VectorObjectBuilder with the rectangle's points.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the rectangle.
     */
    get vector_object_builder() {
        const ret = wasm.rectangle_vector_object_builder(this.__wbg_ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the position of the rectangle.
     * @returns {Point2D} The position of the rectangle.
     */
    get position() {
        const ret = wasm.cubicbeziertuple_first_control(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the size of the rectangle.
     * @returns {BoundingBox} The size of the rectangle.
     */
    get bbox() {
        const ret = wasm.rectangle_bbox(this.__wbg_ptr);
        return BoundingBox.__wrap(ret);
    }
    /**
     * Returns the rotation of the rectangle.
     * @returns {number | undefined} The rotation of the rectangle.
     */
    get rotation() {
        const ret = wasm.rectangle_rotation(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * Returns the top left corner of the rectangle as a Point2D.
     * @returns {Point2D} The top left corner of the rectangle.
     */
    get top_left() {
        const ret = wasm.cubicbeziertuple_first_control(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the top right corner of the rectangle as a Point2D.
     * @returns {Point2D} The top right corner of the rectangle.
     */
    get top_right() {
        const ret = wasm.rectangle_top_right(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the bottom left corner of the rectangle as a Point2D.
     * @returns {Point2D} The bottom left corner of the rectangle.
     */
    get bottom_left() {
        const ret = wasm.rectangle_bottom_left(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the bottom right corner of the rectangle as a Point2D.
     * @returns {Point2D} The bottom right corner of the rectangle.
     */
    get bottom_right() {
        const ret = wasm.rectangle_bottom_right(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the top of the rectangle as a Point2D.
     * @returns {Point2D} The top of the rectangle.
     */
    get top() {
        const ret = wasm.rectangle_top(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the bottom of the rectangle as a Point2D.
     * @returns {Point2D} The bottom of the rectangle.
     */
    get bottom() {
        const ret = wasm.rectangle_bottom(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the left of the rectangle as a Point2D.
     * @returns {Point2D} The left of the rectangle.
     */
    get left() {
        const ret = wasm.rectangle_left(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the right of the rectangle as a Point2D.
     * @returns {Point2D} The right of the rectangle.
     */
    get right() {
        const ret = wasm.rectangle_right(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the area of the rectangle.
     * @returns {number} The area of the rectangle.
     */
    get area() {
        const ret = wasm.rectangle_area(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the center of the rectangle as a Point2D.
     * @returns {Point2D} The center of the rectangle.
     */
    get center() {
        const ret = wasm.rectangle_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
}

const RightTriangleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_righttriangle_free(ptr >>> 0, 1));
/**
 * A RightTriangle is a triangle in which one angle is a right angle.
 */
export class RightTriangle {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RightTriangleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_righttriangle_free(ptr, 0);
    }
    /**
     * Creates a new RightTriangle from a center point, base length, height, rotation, and flip.
     * @param {Point2D} center - The center Point2D of the right triangle.
     * @param {number} base_length - The base length of the right triangle.
     * @param {number} height - The height of the right triangle.
     * @param {number | null} [rotation] - The rotation of the right triangle, if any.
     * @param {boolean | null} [flip] - The flip of the right triangle, by default false.
     */
    constructor(center, base_length, height, rotation, flip) {
        _assertClass(center, Point2D);
        var ptr0 = center.__destroy_into_raw();
        const ret = wasm.righttriangle_new(ptr0, base_length, height, isLikeNone(rotation) ? 0x100000001 : Math.fround(rotation), isLikeNone(flip) ? 0xFFFFFF : flip ? 1 : 0);
        this.__wbg_ptr = ret >>> 0;
        RightTriangleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a Triangle from the right triangle.
     * @returns {Triangle} A triangle.
     */
    get triangle() {
        const ret = wasm.righttriangle_triangle(this.__wbg_ptr);
        return Triangle.__wrap(ret);
    }
    /**
     * Creates a VectorObjectBuilder from the right triangle.
     * @returns {VectorObjectBuilder} A vector object builder with the right triangle's points.
     */
    get vector_object_builder() {
        const ret = wasm.righttriangle_vector_object_builder(this.__wbg_ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the center Point2D of the right triangle.
     * @returns {Point2D} The center point of the right triangle.
     */
    get center() {
        const ret = wasm.equilateraltriangle_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the base length of the right triangle.
     * @returns {number} The base length of the right triangle.
     */
    get base_length() {
        const ret = wasm.equilateraltriangle_side_length(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the height of the right triangle.
     * @returns {number} The height of the right triangle.
     */
    get height() {
        const ret = wasm.righttriangle_height(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the area of the right triangle.
     * @returns {number} The area of the right triangle.
     */
    get area() {
        const ret = wasm.righttriangle_area(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the perimeter of the RightTriangle.
     * @returns {number} The perimeter of the right triangle.
     */
    get perimeter() {
        const ret = wasm.righttriangle_perimeter(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the hypotenuse of the RightTriangle.
     * @returns {number} The hypotenuse of the right triangle.
     */
    get hypotenuse() {
        const ret = wasm.righttriangle_hypotenuse(this.__wbg_ptr);
        return ret;
    }
}

const SquareFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_square_free(ptr >>> 0, 1));
/**
 * A square is a rectangle with equal width and height.
 */
export class Square {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SquareFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_square_free(ptr, 0);
    }
    /**
     * Creates a new Square from a center point, side length, and optional rotation.
     * @param {Point2D} center - The center point of the square as a Point2D.
     * @param {number} side_length - The side length of the square.
     * @param {number | null} [rotation] - The rotation of the square, if any.
     */
    constructor(center, side_length, rotation) {
        _assertClass(center, Point2D);
        var ptr0 = center.__destroy_into_raw();
        const ret = wasm.square_new(ptr0, side_length, isLikeNone(rotation) ? 0x100000001 : Math.fround(rotation));
        this.__wbg_ptr = ret >>> 0;
        SquareFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a new Rectangle from the square.
     * @returns {Rectangle} A Rectangle representing the square.
     */
    get rectangle() {
        const ret = wasm.square_rectangle(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Rectangle.__wrap(ret[0]);
    }
    /**
     * Creates a VectorObjectBuilder from the square.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the square.
     */
    get vector_object_builder() {
        const ret = wasm.square_vector_object_builder(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VectorObjectBuilder.__wrap(ret[0]);
    }
    /**
     * Returns the center point of the square.
     * @returns {Point2D} The center point of the square as a Point2D.
     */
    get center() {
        const ret = wasm.cubicbeziertuple_first_control(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the side length of the square.
     * @returns {number} The side length of the square as a Point2D.
     */
    get side_length() {
        const ret = wasm.square_side_length(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the rotation of the square.
     * @returns {number | undefined} The rotation of the square, if any.
     */
    get rotation() {
        const ret = wasm.rectangle_rotation(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * Returns the area of the square.
     * @returns {number} The area of the square.
     */
    get area() {
        const ret = wasm.square_area(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the perimeter of the square.
     * @returns {number} The perimeter of the square.
     */
    get perimeter() {
        const ret = wasm.square_perimeter(this.__wbg_ptr);
        return ret;
    }
}

const StyleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_style_free(ptr >>> 0, 1));
/**
 * A style with a color, linear gradient, radial gradient, or image.
 */
export class Style {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Style.prototype);
        obj.__wbg_ptr = ptr;
        StyleFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StyleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_style_free(ptr, 0);
    }
    /**
     * Creates a new Style with the given color, linear gradient, radial gradient, or image. It must have exactly one of these.
     * @param {Color | null} [color] - The color of the style, if provided.
     * @param {LinearGradient | null} [linear_gradient] - The linear gradient of the style, if provided.
     * @param {RadialGradient | null} [radial_gradient] - The radial gradient of the style, if provided.
     * @param {ImageBitmap | null} [image] - The image of the style, if provided.
     */
    constructor(color, linear_gradient, radial_gradient, image) {
        let ptr0 = 0;
        if (!isLikeNone(color)) {
            _assertClass(color, Color);
            ptr0 = color.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(linear_gradient)) {
            _assertClass(linear_gradient, LinearGradient);
            ptr1 = linear_gradient.__destroy_into_raw();
        }
        let ptr2 = 0;
        if (!isLikeNone(radial_gradient)) {
            _assertClass(radial_gradient, RadialGradient);
            ptr2 = radial_gradient.__destroy_into_raw();
        }
        let ptr3 = 0;
        if (!isLikeNone(image)) {
            _assertClass(image, ImageBitmap);
            ptr3 = image.__destroy_into_raw();
        }
        const ret = wasm.style_new(ptr0, ptr1, ptr2, ptr3);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        this.__wbg_ptr = ret[0] >>> 0;
        StyleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Creates a new Style with the given color.
     * @param {Color} color - The color of the style.
     * @returns {Style} A new style from the color.
     */
    static from_color(color) {
        _assertClass(color, Color);
        var ptr0 = color.__destroy_into_raw();
        const ret = wasm.style_from_color(ptr0);
        return Style.__wrap(ret);
    }
    /**
     * Creates a new Style with the given linear gradient.
     * @param {LinearGradient} gradient - The linear gradient of the style.
     * @returns {Style} A new style from the linear gradient.
     */
    static from_linear_gradient(gradient) {
        _assertClass(gradient, LinearGradient);
        var ptr0 = gradient.__destroy_into_raw();
        const ret = wasm.style_from_linear_gradient(ptr0);
        return Style.__wrap(ret);
    }
    /**
     * Creates a new Style with the given radial gradient.
     * @param {RadialGradient} gradient
     * @returns {Style} A new style from the radial gradient.
     */
    static from_radial_gradient(gradient) {
        _assertClass(gradient, RadialGradient);
        var ptr0 = gradient.__destroy_into_raw();
        const ret = wasm.style_from_radial_gradient(ptr0);
        return Style.__wrap(ret);
    }
    /**
     * Creates a new Style with the given image.
     * @param {ImageBitmap} image - The image of the style.
     * @returns {Style} A new style from the image.
     */
    static from_image(image) {
        _assertClass(image, ImageBitmap);
        var ptr0 = image.__destroy_into_raw();
        const ret = wasm.style_from_image(ptr0);
        return Style.__wrap(ret);
    }
    /**
     * Returns the default Style, which is a color with the default color.
     * @returns {Style} The default style.
     */
    static default_style() {
        const ret = wasm.style_default_style();
        return Style.__wrap(ret);
    }
    /**
     * Fades the Style by a given amount.
     * @param {number} amount - The amount to fade the style by.
     * @returns {Style} The faded style.
     */
    fade(amount) {
        const ret = wasm.style_fade(this.__wbg_ptr, amount);
        return Style.__wrap(ret);
    }
    /**
     * Gets the Color of the style, if it's a color.
     * @returns {Color | undefined} The color of the style.
     */
    get color() {
        const ret = wasm.style_color(this.__wbg_ptr);
        return ret === 0 ? undefined : Color.__wrap(ret);
    }
    /**
     * Sets the style to a Color.
     * @param {Color} color - The color of the style.
     */
    set color(color) {
        _assertClass(color, Color);
        var ptr0 = color.__destroy_into_raw();
        wasm.style_set_color(this.__wbg_ptr, ptr0);
    }
    /**
     * Gets the LinearGradient of the style, if it's a linear gradient.
     * @returns {LinearGradient | undefined} The linear gradient of the style.
     */
    get linear_gradient() {
        const ret = wasm.style_linear_gradient(this.__wbg_ptr);
        return ret === 0 ? undefined : LinearGradient.__wrap(ret);
    }
    /**
     * Sets the style to a LinearGradient.
     * @param {LinearGradient} linear_gradient - The linear gradient of the style.
     */
    set linear_gradient(linear_gradient) {
        _assertClass(linear_gradient, LinearGradient);
        var ptr0 = linear_gradient.__destroy_into_raw();
        wasm.style_set_linear_gradient(this.__wbg_ptr, ptr0);
    }
    /**
     * Gets the RadialGradient of the style, if it's a radial gradient.
     * @returns {RadialGradient | undefined} The radial gradient of the style.
     */
    get radial_gradient() {
        const ret = wasm.style_radial_gradient(this.__wbg_ptr);
        return ret === 0 ? undefined : RadialGradient.__wrap(ret);
    }
    /**
     * Sets the style to a RadialGradient.
     * @param {RadialGradient} radial_gradient - The radial gradient of the style.
     */
    set radial_gradient(radial_gradient) {
        _assertClass(radial_gradient, RadialGradient);
        var ptr0 = radial_gradient.__destroy_into_raw();
        wasm.style_set_radial_gradient(this.__wbg_ptr, ptr0);
    }
    /**
     * Gets the ImageBitmap of the style, if it's an image.
     * @returns {ImageBitmap | undefined} The image of the style.
     */
    get image() {
        const ret = wasm.style_image(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageBitmap.__wrap(ret);
    }
    /**
     * Sets the style to an ImageBitmap.
     * @param {ImageBitmap} image
     */
    set image(image) {
        _assertClass(image, ImageBitmap);
        var ptr0 = image.__destroy_into_raw();
        wasm.style_set_image(this.__wbg_ptr, ptr0);
    }
    /**
     * Gets the Color at a given point.
     * @param {Point2D} p - The x coordinate of the point.
     * @returns {Color} The color at the given point.
     */
    color_at(p) {
        _assertClass(p, Point2D);
        var ptr0 = p.__destroy_into_raw();
        const ret = wasm.style_color_at(this.__wbg_ptr, ptr0);
        return Color.__wrap(ret);
    }
    /**
     * Linearly interpolates between two Styles given a progress value.
     * @param {Style} style1 - The first style.
     * @param {Style} style2 - The second style.
     * @param {number} t - The progress value.
     * @returns {Style} The interpolated style.
     */
    static lerp(style1, style2, t) {
        _assertClass(style1, Style);
        _assertClass(style2, Style);
        const ret = wasm.style_lerp(style1.__wbg_ptr, style2.__wbg_ptr, t);
        return Style.__wrap(ret);
    }
}

const TransformationMatrixFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transformationmatrix_free(ptr >>> 0, 1));
/**
 * A TransformationMatrix is a 2D transformation matrix following the CSS matrix transform format.
 */
export class TransformationMatrix {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransformationMatrix.prototype);
        obj.__wbg_ptr = ptr;
        TransformationMatrixFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransformationMatrixFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transformationmatrix_free(ptr, 0);
    }
    /**
     * The a component of the matrix.
     * @returns {number}
     */
    get a() {
        const ret = wasm.__wbg_get_transformationmatrix_a(this.__wbg_ptr);
        return ret;
    }
    /**
     * The a component of the matrix.
     * @param {number} arg0
     */
    set a(arg0) {
        wasm.__wbg_set_transformationmatrix_a(this.__wbg_ptr, arg0);
    }
    /**
     * The b component of the matrix.
     * @returns {number}
     */
    get b() {
        const ret = wasm.__wbg_get_transformationmatrix_b(this.__wbg_ptr);
        return ret;
    }
    /**
     * The b component of the matrix.
     * @param {number} arg0
     */
    set b(arg0) {
        wasm.__wbg_set_transformationmatrix_b(this.__wbg_ptr, arg0);
    }
    /**
     * The c component of the matrix.
     * @returns {number}
     */
    get c() {
        const ret = wasm.__wbg_get_transformationmatrix_c(this.__wbg_ptr);
        return ret;
    }
    /**
     * The c component of the matrix.
     * @param {number} arg0
     */
    set c(arg0) {
        wasm.__wbg_set_transformationmatrix_c(this.__wbg_ptr, arg0);
    }
    /**
     * The d component of the matrix.
     * @returns {number}
     */
    get d() {
        const ret = wasm.__wbg_get_transformationmatrix_d(this.__wbg_ptr);
        return ret;
    }
    /**
     * The d component of the matrix.
     * @param {number} arg0
     */
    set d(arg0) {
        wasm.__wbg_set_transformationmatrix_d(this.__wbg_ptr, arg0);
    }
    /**
     * The e component of the matrix.
     * @returns {number}
     */
    get e() {
        const ret = wasm.__wbg_get_transformationmatrix_e(this.__wbg_ptr);
        return ret;
    }
    /**
     * The e component of the matrix.
     * @param {number} arg0
     */
    set e(arg0) {
        wasm.__wbg_set_transformationmatrix_e(this.__wbg_ptr, arg0);
    }
    /**
     * The f component of the matrix.
     * @returns {number}
     */
    get f() {
        const ret = wasm.__wbg_get_transformationmatrix_f(this.__wbg_ptr);
        return ret;
    }
    /**
     * The f component of the matrix.
     * @param {number} arg0
     */
    set f(arg0) {
        wasm.__wbg_set_transformationmatrix_f(this.__wbg_ptr, arg0);
    }
    /**
     * Creates a new TransformationMatrix with the given components.
     * @param {number} a - The a component of the matrix.
     * @param {number} b - The b component of the matrix.
     * @param {number} c - The c component of the matrix.
     * @param {number} d - The d component of the matrix.
     * @param {number} e - The e component of the matrix.
     * @param {number} f - The f component of the matrix.
     */
    constructor(a, b, c, d, e, f) {
        const ret = wasm.transformationmatrix_new(a, b, c, d, e, f);
        this.__wbg_ptr = ret >>> 0;
        TransformationMatrixFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the identity matrix.
     * @returns {TransformationMatrix} The identity matrix.
     */
    static identity() {
        const ret = wasm.transformationmatrix_identity();
        return TransformationMatrix.__wrap(ret);
    }
    /**
     * Gets the matrix that translates by a given x and y value.
     * @param {number} x - The x value to translate by.
     * @param {number} y - The y value to translate by.
     * @returns {TransformationMatrix} The translated matrix.
     */
    static translate(x, y) {
        const ret = wasm.transformationmatrix_translate(x, y);
        return TransformationMatrix.__wrap(ret);
    }
    /**
     * Gets the matrix that scales by a given x and y value.
     * @param {number} x - The x value to scale by.
     * @param {number} y - The y value to scale by.
     * @returns {TransformationMatrix} The scaled matrix.
     */
    static scale(x, y) {
        const ret = wasm.transformationmatrix_scale(x, y);
        return TransformationMatrix.__wrap(ret);
    }
    /**
     * Applies another TransformationMatrix to this matrix.
     * @param {TransformationMatrix} other
     */
    apply(other) {
        _assertClass(other, TransformationMatrix);
        wasm.transformationmatrix_apply(this.__wbg_ptr, other.__wbg_ptr);
    }
    /**
     * Gets the matrix that rotates by a given angle in radians.
     * @param {number} angle - The angle in radians to rotate by.
     * @returns {TransformationMatrix} The rotated matrix.
     */
    static rotate(angle) {
        const ret = wasm.transformationmatrix_rotate(angle);
        return TransformationMatrix.__wrap(ret);
    }
    /**
     * Gets the matrix that undoes this TransformationMatrix.
     * @returns {TransformationMatrix} The inverse matrix.
     */
    inverse() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.transformationmatrix_inverse(ptr);
        return TransformationMatrix.__wrap(ret);
    }
}

const TriangleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_triangle_free(ptr >>> 0, 1));
/**
 * A Triangle is a polygon with three edges and three vertices.
 */
export class Triangle {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Triangle.prototype);
        obj.__wbg_ptr = ptr;
        TriangleFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TriangleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_triangle_free(ptr, 0);
    }
    /**
     * Creates a new Triangle object from three points.
     * @param {Point2D} a - The first vertex of the triangle as Point2D.
     * @param {Point2D} b - The second vertex of the triangle as Point2D.
     * @param {Point2D} c - The third vertex of the triangle as Point2D.
     */
    constructor(a, b, c) {
        _assertClass(a, Point2D);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, Point2D);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, Point2D);
        var ptr2 = c.__destroy_into_raw();
        const ret = wasm.triangle_new(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        TriangleFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the area of the triangle.
     * @returns {number} The area of the triangle.
     */
    get area() {
        const ret = wasm.triangle_area(this.__wbg_ptr);
        return ret;
    }
    /**
     * Returns the perimeter of the triangle.
     * @returns {number} The perimeter of the triangle.
     */
    get perimeter() {
        const ret = wasm.triangle_perimeter(this.__wbg_ptr);
        return ret;
    }
    /**
     * Creates a VectorObjectBuilder with the triangle's points.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder with the triangle's points.
     */
    vector_object_builder() {
        const ret = wasm.triangle_vector_object_builder(this.__wbg_ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Returns the first vertex of the triangle as Point2D.
     * @returns {Point2D} The first vertex of the triangle.
     */
    get a() {
        const ret = wasm.triangle_a(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the second vertex of the triangle as Point2D.
     * @returns {Point2D} The second vertex of the triangle.
     */
    get b() {
        const ret = wasm.equilateraltriangle_center(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
    /**
     * Returns the third vertex of the triangle as Point2D.
     * @returns {Point2D} The third vertex of the triangle.
     */
    get c() {
        const ret = wasm.triangle_c(this.__wbg_ptr);
        return Point2D.__wrap(ret);
    }
}

const TypstFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_typst_free(ptr >>> 0, 1));
/**
 * A Typst is a typesetting object that can be used to render math text with Typst.
 */
export class Typst {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypstFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_typst_free(ptr, 0);
    }
    /**
     * Creates a new Typst object from a source string.
     * @param {string} source - The source of the typesetting object.
     */
    constructor(source) {
        const ptr0 = passStringToWasm0(source, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.typst_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        TypstFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the source of the Typst object.
     * @returns {string} The source of the typesetting object.
     */
    get source() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.typst_source(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Renders the Typst object to an SVG string.
     * @param {FontFace[] | null} [font_faces] - The font faces to use when rendering the typesetting object.
     * @returns {string} The SVG string.
     */
    render_to_svg(font_faces) {
        let deferred3_0;
        let deferred3_1;
        try {
            var ptr0 = isLikeNone(font_faces) ? 0 : passArrayJsValueToWasm0(font_faces, wasm.__wbindgen_malloc);
            var len0 = WASM_VECTOR_LEN;
            const ret = wasm.typst_render_to_svg(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * Renders the Typst object to a VectorObjectBuilder.
     * @param {FontFace[] | null} [font_faces] - The FontFaces to use when rendering the typesetting object, if any.
     * @returns {VectorObjectBuilder} A VectorObjectBuilder representing the typesetting object.
     */
    render_to_vector_object_builder(font_faces) {
        var ptr0 = isLikeNone(font_faces) ? 0 : passArrayJsValueToWasm0(font_faces, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.typst_render_to_vector_object_builder(this.__wbg_ptr, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VectorObjectBuilder.__wrap(ret[0]);
    }
}

const VectorObjectFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vectorobject_free(ptr >>> 0, 1));
/**
 * A VectorObject is a vector object that can be drawn on a vector graphics canvas.
 */
export class VectorObject {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VectorObject.prototype);
        obj.__wbg_ptr = ptr;
        VectorObjectFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof VectorObject)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VectorObjectFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vectorobject_free(ptr, 0);
    }
    /**
     * Creates a new VectorObject.
     * @param {Path2D} path - The Path2D of the vector object.
     * @param {Style} fill - The fill Style of the vector object.
     * @param {string} fill_rule - The fill rule of the vector object.
     * @param {Style} stroke - The stroke Style of the vector object.
     * @param {number} stroke_width - The stroke width of the vector object.
     * @param {string} stroke_line_cap - The stroke line cap of the vector object.
     * @param {string} stroke_line_join - The stroke line join of the vector object.
     * @param {number} stroke_miter_limit - The stroke miter limit of the vector object.
     * @param {number} stroke_dash_offset - The stroke dash offset of the vector object.
     * @param {number[]} stroke_dash_array - The stroke dash array of the vector object.
     * @param {VectorObject[]} children - The children of the vector object.
     * @param {string | null | undefined} name - The name of the vector object.
     * @param {TransformationMatrix} transform - The TransformationMatrix of the vector object.
     */
    constructor(path, fill, fill_rule, stroke, stroke_width, stroke_line_cap, stroke_line_join, stroke_miter_limit, stroke_dash_offset, stroke_dash_array, children, name, transform) {
        _assertClass(path, Path2D);
        var ptr0 = path.__destroy_into_raw();
        _assertClass(fill, Style);
        var ptr1 = fill.__destroy_into_raw();
        const ptr2 = passStringToWasm0(fill_rule, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        _assertClass(stroke, Style);
        var ptr3 = stroke.__destroy_into_raw();
        const ptr4 = passStringToWasm0(stroke_line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len4 = WASM_VECTOR_LEN;
        const ptr5 = passStringToWasm0(stroke_line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len5 = WASM_VECTOR_LEN;
        const ptr6 = passArrayF32ToWasm0(stroke_dash_array, wasm.__wbindgen_malloc);
        const len6 = WASM_VECTOR_LEN;
        const ptr7 = passArrayJsValueToWasm0(children, wasm.__wbindgen_malloc);
        const len7 = WASM_VECTOR_LEN;
        var ptr8 = isLikeNone(name) ? 0 : passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len8 = WASM_VECTOR_LEN;
        _assertClass(transform, TransformationMatrix);
        var ptr9 = transform.__destroy_into_raw();
        const ret = wasm.vectorobject_new(ptr0, ptr1, ptr2, len2, ptr3, stroke_width, ptr4, len4, ptr5, len5, stroke_miter_limit, stroke_dash_offset, ptr6, len6, ptr7, len7, ptr8, len8, ptr9);
        this.__wbg_ptr = ret >>> 0;
        VectorObjectFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Clones the vector object.
     * @returns {VectorObject} The cloned vector object.
     */
    clone() {
        const ret = wasm.vectorobject_clone(this.__wbg_ptr);
        return VectorObject.__wrap(ret);
    }
    /**
     * Creates a new empty VectorObject.
     * @returns {VectorObject} A new empty vector object.
     */
    static default_vector_object() {
        const ret = wasm.vectorobject_default_vector_object();
        return VectorObject.__wrap(ret);
    }
    /**
     * Gets the Path2D of the VectorObject.
     * @returns {Path2D} The path of the vector object.
     */
    get path() {
        const ret = wasm.vectorobject_path(this.__wbg_ptr);
        return Path2D.__wrap(ret);
    }
    /**
     * Gets the fill Style of the VectorObject.
     * @returns {Style} The fill style of the vector object.
     */
    get fill() {
        const ret = wasm.vectorobject_fill(this.__wbg_ptr);
        return Style.__wrap(ret);
    }
    /**
     * Gets the fill rule of the VectorObject.
     * @returns {string} The fill rule of the vector object.
     */
    get fill_rule() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vectorobject_fill_rule(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Gets the stroke Style of the VectorObject.
     * @returns {Style} The stroke style of the vector object.
     */
    get stroke() {
        const ret = wasm.vectorobject_stroke(this.__wbg_ptr);
        return Style.__wrap(ret);
    }
    /**
     * Gets the stroke width of the VectorObject.
     * @returns {number} The stroke width of the vector object.
     */
    get stroke_width() {
        const ret = wasm.vectorobject_stroke_width(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the stroke line cap of the VectorObject.
     * @returns {string} The stroke line cap of the vector object.
     */
    get stroke_line_cap() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vectorobject_stroke_line_cap(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Gets the stroke line join of the VectorObject.
     * @returns {string} The stroke line join of the vector object.
     */
    get stroke_line_join() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vectorobject_stroke_line_join(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Gets the stroke miter limit of VectorObject.
     * @returns {number} The stroke miter limit of the vector object.
     */
    get stroke_miter_limit() {
        const ret = wasm.vectorobject_stroke_miter_limit(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the stroke dash offset of the VectorObject.
     * @returns {number} The stroke dash offset of the vector object.
     */
    get stroke_dash_offset() {
        const ret = wasm.vectorobject_stroke_dash_offset(this.__wbg_ptr);
        return ret;
    }
    /**
     * Gets the stroke dash array of the VectorObject.
     * @returns {number[]} The stroke dash array of the vector object.
     */
    get stroke_dash_array() {
        const ret = wasm.vectorobject_stroke_dash_array(this.__wbg_ptr);
        var v1 = getArrayF32FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Gets the children of the VectorObject.
     * @returns {VectorObject[]} The children of the vector object.
     */
    get children() {
        const ret = wasm.vectorobject_children(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Gets the name of the VectorObject.
     * @returns {string | undefined} The name of the vector object.
     */
    get name() {
        const ret = wasm.vectorobject_name(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * Gets the transformation matrix of the VectorObject.
     * @returns {TransformationMatrix} The transformation matrix of the vector object.
     */
    get transform() {
        const ret = wasm.vectorobject_transform(this.__wbg_ptr);
        return TransformationMatrix.__wrap(ret);
    }
    /**
     * Gets the Path2D with the applied TransformationMatrix.
     * @returns {Path2D} The path of the vector object with the applied transform.
     */
    get actual_path() {
        const ret = wasm.vectorobject_actual_path(this.__wbg_ptr);
        return Path2D.__wrap(ret);
    }
    /**
     * Gets the BoundingBox of the VectorObject.
     * @param {boolean | null} [recursive] - Whether to include the children of the vector object.
     * @returns {BoundingBox | undefined} The bounding box of the vector object.
     */
    bounding_box(recursive) {
        const ret = wasm.vectorobject_bounding_box(this.__wbg_ptr, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return ret === 0 ? undefined : BoundingBox.__wrap(ret);
    }
    /**
     * Gets the center Point2D of the VectorObject.
     * @returns {Point2D | undefined} The center of the vector object.
     */
    get center() {
        const ret = wasm.vectorobject_center(this.__wbg_ptr);
        return ret === 0 ? undefined : Point2D.__wrap(ret);
    }
    /**
     * Gets the critical Point2D of the VectorObject.
     * @param {number} key_x - The x key of the critical point. If negative, the minimum x is returned. If positive, the maximum x is returned. If zero, the center x is returned.
     * @param {number} key_y - The y key of the critical point. If negative, the minimum y is returned. If positive, the maximum y is returned. If zero, the center y is returned.
     * @param {boolean | null} [recursive] - Whether to include the children of the vector object.
     * @returns {Point2D | undefined} The critical point of the vector object.
     */
    get_critical_point(key_x, key_y, recursive) {
        const ret = wasm.vectorobject_get_critical_point(this.__wbg_ptr, key_x, key_y, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return ret === 0 ? undefined : Point2D.__wrap(ret);
    }
    /**
     * Gets the children of the VectorObject recursively.
     * @param {boolean | null} [with_points] - Whether to include the children of the children of the vector object, default is false.
     * @returns {VectorObject[]} The children of the vector object.
     */
    get_children_recursive(with_points) {
        const ret = wasm.vectorobject_get_children_recursive(this.__wbg_ptr, isLikeNone(with_points) ? 0xFFFFFF : with_points ? 1 : 0);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Gets the number of cubic bezier curves in the vector object.
     * @returns {number} The number of curves in the vector object.
     */
    get num_curves() {
        const ret = wasm.vectorobject_num_curves(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Gets the number of points in the VectorObject's path.
     * @returns {number} The number of points in the vector object.
     */
    get num_points() {
        const ret = wasm.vectorobject_num_points(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Gets the number of children in the VectorObject.
     * @returns {number} The number of children in the vector object.
     */
    get num_children() {
        const ret = wasm.vectorobject_num_children(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Gets whether the VectorObject's path is closed.
     * @returns {boolean} Whether the vector object's path is closed.
     */
    get is_closed() {
        const ret = wasm.vectorobject_is_closed(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Gets the subpaths of the VectorObject.
     * @returns {Path2D[]} The subpaths of the vector object.
     */
    get subpaths() {
        const ret = wasm.vectorobject_subpaths(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Gets the width of the VectorObject.
     * @returns {number | undefined} The width of the vector object.
     */
    get width() {
        const ret = wasm.vectorobject_width(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * Gets the height of the VectorObject.
     * @returns {number | undefined} The height of the vector object.
     */
    get height() {
        const ret = wasm.vectorobject_height(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * Slices the VectorObject's children.
     * @param {number} start - The start index of the children to slice.
     * @param {number} end - The end index of the children to slice.
     * @returns {VectorObject[]} The sliced children of the vector object.
     */
    slice_children(start, end) {
        const ret = wasm.vectorobject_slice_children(this.__wbg_ptr, start, end);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Gets the children of the VectorObject with the given names.
     * @param {string[]} names - The names of the children to get.
     * @returns {VectorObject[]} The children with the given names.
     */
    get_children_by_names(names) {
        const ptr0 = passArrayJsValueToWasm0(names, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobject_get_children_by_names(this.__wbg_ptr, ptr0, len0);
        var v2 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v2;
    }
}

const VectorObjectBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vectorobjectbuilder_free(ptr >>> 0, 1));
/**
 * A VectorObjectBuilder can be used to build a VectorObject with operations.
 */
export class VectorObjectBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VectorObjectBuilder.prototype);
        obj.__wbg_ptr = ptr;
        VectorObjectBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof VectorObjectBuilder)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VectorObjectBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vectorobjectbuilder_free(ptr, 0);
    }
    /**
     * Creates a new VectorObjectBuilder from a VectorObject.
     * @param {VectorObject} vector_object - The vector object to start building on.
     */
    constructor(vector_object) {
        _assertClass(vector_object, VectorObject);
        const ret = wasm.vectorobjectbuilder_new(vector_object.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        VectorObjectBuilderFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Returns the default tip shape pointing to the right and centered at the origin as a VectorObjectBuilder.
     * @param {number} tip_length - The length of the tip shape.
     * @returns {VectorObjectBuilder} The default tip shape pointing to the right and centered at the origin.
     */
    static default_tip_shape(tip_length) {
        const ret = wasm.vectorobjectbuilder_default_tip_shape(tip_length);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Creates a new VectorObjectBuilder from an SVG string.
     * @param {string} svg - The SVG string to create the vector object builder from.
     * @param {FontFace[] | null} [font_faces] - Data from font faces to use for text rendering.
     * @returns {VectorObjectBuilder} A new vector object builder.
     */
    static from_svg(svg, font_faces) {
        const ptr0 = passStringToWasm0(svg, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(font_faces) ? 0 : passArrayJsValueToWasm0(font_faces, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_from_svg(ptr0, len0, ptr1, len1);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Clones the VectorObjectBuilder.
     * @returns {VectorObjectBuilder} A clone of the vector object builder.
     */
    clone() {
        const ret = wasm.vectorobjectbuilder_clone(this.__wbg_ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Creates a VectorObjectBuilder representing an empty VectorObject.
     * @returns {VectorObjectBuilder} A new vector object builder representing an empty vector object.
     */
    static default_vector_object_builder() {
        const ret = wasm.vectorobjectbuilder_default_vector_object_builder();
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Shifts the VectorObjectBuilder by the given dx and dy.
     * @param {number} dx - The x-coordinate to translate the vector object by.
     * @param {number} dy - The y-coordinate to translate the vector object by.
     * @param {boolean | null} [recursive] - Whether to apply the shift operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the shift operation.
     */
    shift(dx, dy, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_shift(ptr, dx, dy, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Centers the VectorObjectBuilder at the given Point2D.
     * @param {Point2D} point - The point to center the vector object at.
     * @param {boolean | null} [recursive] - Whether to apply the move to operation to the children of the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the move to operation.
     */
    move_to(point, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_move_to(ptr, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Scales the VectorObjectBuilder by the given factor.
     * @param {number} factor_x - The factor to scale the vector object by.
     * @param {number} factor_y - The factor to scale the vector object by.
     * @param {Point2D | null} [about_point] - The point to scale the vector object about.
     * @param {boolean | null} [recursive] - Whether to apply the scale operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the scale operation.
     */
    scale(factor_x, factor_y, about_point, recursive) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(about_point)) {
            _assertClass(about_point, Point2D);
            ptr0 = about_point.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_scale(ptr, factor_x, factor_y, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Scales the VectorObjectBuilder to the given width.
     * @param {number} width - The width to scale the vector object to.
     * @param {boolean | null} [stretch] - Whether to stretch the vector object to the given width, default is false.
     * @param {Point2D | null} [about_point] - The point to scale the vector object about, default is the center of the bounding box.
     * @param {boolean | null} [recursive] - Whether to apply the scale to width operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the scale to width operation.
     */
    scale_to_width(width, stretch, about_point, recursive) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(about_point)) {
            _assertClass(about_point, Point2D);
            ptr0 = about_point.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_scale_to_width(ptr, width, isLikeNone(stretch) ? 0xFFFFFF : stretch ? 1 : 0, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Scales the VectorObjectBuilder to the given height.
     * @param {number} height - The height to scale the vector object to.
     * @param {boolean | null} [stretch] - Whether to stretch the vector object to the given height, default is false.
     * @param {Point2D | null} [about_point] - The point to scale the vector object about, default is the center of the bounding box.
     * @param {boolean | null} [recursive] - Whether to apply the scale to height operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the scale to height operation.
     */
    scale_to_height(height, stretch, about_point, recursive) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(about_point)) {
            _assertClass(about_point, Point2D);
            ptr0 = about_point.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_scale_to_height(ptr, height, isLikeNone(stretch) ? 0xFFFFFF : stretch ? 1 : 0, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Rotates the VectorObjectBuilder by the given angle in radians.
     * @param {number} angle - The angle in radians to rotate the vector object by.
     * @param {Point2D | null} [from_point] - The point to rotate the vector object about, default is the center of the bounding box.
     * @param {boolean | null} [recursive] - Whether to apply the rotate operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the rotate operation.
     */
    rotate(angle, from_point, recursive) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(from_point)) {
            _assertClass(from_point, Point2D);
            ptr0 = from_point.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_rotate(ptr, angle, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the TransformationMatrix of the VectorObjectBuilder.
     * @param {TransformationMatrix} matrix - The matrix in CSS format to transform the vector object by.
     * @param {boolean | null} [recursive] - Whether to apply the transform operation to the children of the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the transform operation.
     */
    set_transform(matrix, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(matrix, TransformationMatrix);
        var ptr0 = matrix.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_transform(ptr, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Applies the TransformationMatrix to the VectorObjectBuilder.
     * @param {TransformationMatrix} matrix - The matrix in CSS format to apply to the vector object.
     * @param {boolean | null} [recursive] - Whether to apply the apply transform operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the apply transform operation.
     */
    apply_transform(matrix, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(matrix, TransformationMatrix);
        var ptr0 = matrix.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_apply_transform(ptr, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Adds a child to the VectorObjectBuilder.
     * @param {VectorObjectBuilder[]} children - The children to add at the end of the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the add children operation.
     */
    add_children(children) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(children, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_add_children(ptr, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Inserts a child into the VectorObjectBuilder at the given index.
     * @param {number} index - The index to insert the child at.
     * @param {VectorObjectBuilder} child - The child to insert into the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the insert child operation.
     */
    insert_child(index, child) {
        const ptr = this.__destroy_into_raw();
        _assertClass(child, VectorObjectBuilder);
        var ptr0 = child.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_insert_child(ptr, index, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Inserts children into the VectorObjectBuilder at the given index.
     * @param {number} index - The index to insert the children at.
     * @param {VectorObjectBuilder[]} children - The children to insert into the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the insert children operation.
     */
    insert_children(index, children) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(children, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_insert_children(ptr, index, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Removes a child from the VectorObjectBuilder given its index.
     * @param {number} index - The index of the child to remove from the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the remove child by index operation.
     */
    remove_child_by_index(index) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_remove_child_by_index(ptr, index);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Removes a child from the VectorObjectBuilder given its name.
     * @param {string} name - The name of the child to remove from the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the remove child by name operation.
     */
    remove_child_by_name(name) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_remove_child_by_name(ptr, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Matches the style properties of the VectorObjectBuilder with another VectorObject.
     * @param {VectorObjectBuilder} vector_object_builder - The vector object to match the style properties of.
     * @returns {VectorObjectBuilder} The vector object being built with the match style properties operation.
     */
    match_style_properties(vector_object_builder) {
        const ptr = this.__destroy_into_raw();
        _assertClass(vector_object_builder, VectorObjectBuilder);
        var ptr0 = vector_object_builder.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_match_style_properties(ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the actual path of the VectorObjectBuilder. Actual path is the path that is drawn with its transformation matrix applied.
     * @param {Path2D} actual_path - The path to set the vector object to.
     * @returns {VectorObjectBuilder} The vector object being built with the set actual path operation.
     */
    set_actual_path(actual_path) {
        const ptr = this.__destroy_into_raw();
        _assertClass(actual_path, Path2D);
        var ptr0 = actual_path.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_actual_path(ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Trims the stroke of the VectorObjectBuilder to the given start and end proportions.
     * @param {number} start - The proportion of the path to start at.
     * @param {number} end - The proportion of the path to end at.
     * @param {number | null} [samples] - Number of samples to compute the length of each cubic bezier curve segment.
     * @param {number | null} [extra_length] - Extra length to add to each length computation to ensure the path is not too short.
     * @param {boolean | null} [recursive] - Whether to apply the become partial operation to the children of the vector object, default is true
     * @returns {VectorObjectBuilder} The vector object being built with the become partial operation.
     */
    become_partial(start, end, samples, extra_length, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_become_partial(ptr, start, end, isLikeNone(samples) ? 0x100000001 : (samples) >>> 0, isLikeNone(extra_length) ? 0x100000001 : Math.fround(extra_length), isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Trims the path of the VectorObjectBuilder to the given start and end proportions.
     * @param {number} start - The proportion of the path to start at.
     * @param {number} end - The proportion of the path to end at.
     * @param {boolean | null} [recursive] - Whether to apply the pointwise become partial operation to the children of the vector object, default is true
     * @returns {VectorObjectBuilder}
     */
    pointwise_become_partial(start, end, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_pointwise_become_partial(ptr, start, end, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Moves the current drawing point to the given Point2D.
     * @param {Point2D} point - The point to start a new bezier curve at.
     * @returns {VectorObjectBuilder} The vector object being built with the move point operation.
     */
    move_point(point) {
        const ptr = this.__destroy_into_raw();
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_move_point(ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Draws a line from the current drawing point to the given Point2D.
     * @param {Point2D} p - The point to draw a line to.
     * @returns {VectorObjectBuilder} The vector object being built with the line to operation.
     */
    line_to(p) {
        const ptr = this.__destroy_into_raw();
        _assertClass(p, Point2D);
        var ptr0 = p.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_line_to(ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Draws a quadratic bezier curve from the current drawing point with the given control Point2D and end Point2D.
     * @param {Point2D} p1 - The control point of the quadratic curve.
     * @param {Point2D} p2 - The end point of the quadratic curve.
     * @returns {VectorObjectBuilder} The vector object being built with the quadratic curve to operation.
     */
    quadratic_curve_to(p1, p2) {
        const ptr = this.__destroy_into_raw();
        _assertClass(p1, Point2D);
        var ptr0 = p1.__destroy_into_raw();
        _assertClass(p2, Point2D);
        var ptr1 = p2.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_quadratic_curve_to(ptr, ptr0, ptr1);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Draws a cubic bezier curve from the current drawing point with the given control Point2Ds and end Point2D.
     * @param {Point2D} p1 - The first control point of the bezier curve.
     * @param {Point2D} p2 - The second control point of the bezier curve.
     * @param {Point2D} p3 - The end point of the bezier curve.
     * @returns {VectorObjectBuilder} The vector object being built with the bezier curve to operation.
     */
    bezier_curve_to(p1, p2, p3) {
        const ptr = this.__destroy_into_raw();
        _assertClass(p1, Point2D);
        var ptr0 = p1.__destroy_into_raw();
        _assertClass(p2, Point2D);
        var ptr1 = p2.__destroy_into_raw();
        _assertClass(p3, Point2D);
        var ptr2 = p3.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_bezier_curve_to(ptr, ptr0, ptr1, ptr2);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Closes the current subpath of the VectorObjectBuilder.
     * @returns {VectorObjectBuilder} The vector object being built with the close operation.
     */
    close() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_close(ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Fades fill's opacity of the VectorObjectBuilder by the given factor.
     * @param {number} factor - The factor to fade the fill style by.
     * @param {boolean | null} [recursive] - Whether to apply the fade fill operation to the children of the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the fade fill operation.
     */
    fade_fill(factor, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_fade_fill(ptr, factor, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Fades stroke's opacity of the VectorObjectBuilder by the given factor.
     * @param {number} factor - The factor to fade the stroke style by.
     * @param {boolean | null} [recursive] - Whether to apply the fade stroke operation to the children of the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the fade stroke operation.
     */
    fade_stroke(factor, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_fade_stroke(ptr, factor, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the Path2D of the VectorObjectBuilder.
     * @param {Path2D} path - The path to set the vector object to.
     * @returns {VectorObjectBuilder} The vector object being built with the set path operation.
     */
    set_path(path) {
        const ptr = this.__destroy_into_raw();
        _assertClass(path, Path2D);
        var ptr0 = path.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_path(ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the fill Style of the VectorObjectBuilder.
     * @param {Style} fill - The fill style to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set fill operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set fill operation.
     */
    set_fill(fill, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(fill, Style);
        var ptr0 = fill.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_fill(ptr, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the fill rule of the VectorObjectBuilder.
     * @param {string} fill_rule - The fill rule to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set fill rule operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set fill rule operation.
     */
    set_fill_rule(fill_rule, recursive) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(fill_rule, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_fill_rule(ptr, ptr0, len0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke Style of the VectorObjectBuilder.
     * @param {Style} stroke - The stroke style to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke operation.
     */
    set_stroke(stroke, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(stroke, Style);
        var ptr0 = stroke.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_stroke(ptr, ptr0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke width of the VectorObjectBuilder.
     * @param {number} stroke_width - The stroke width to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke width operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke width operation.
     */
    set_stroke_width(stroke_width, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_stroke_width(ptr, stroke_width, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke line cap of the VectorObjectBuilder.
     * @param {string} stroke_line_cap - The stroke line cap to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke line cap operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke line cap operation.
     */
    set_stroke_line_cap(stroke_line_cap, recursive) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(stroke_line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_stroke_line_cap(ptr, ptr0, len0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke line join of the VectorObjectBuilder.
     * @param {string} stroke_line_join - The stroke line join to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke line join operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke line join operation.
     */
    set_stroke_line_join(stroke_line_join, recursive) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(stroke_line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_stroke_line_join(ptr, ptr0, len0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke miter limit of the VectorObjectBuilder.
     * @param {number} stroke_miter_limit - The stroke miter limit to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke miter limit operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke miter limit operation.
     */
    set_stroke_miter_limit(stroke_miter_limit, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_stroke_miter_limit(ptr, stroke_miter_limit, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke dash offset of the VectorObjectBuilder.
     * @param {number} stroke_dash_offset - The stroke dash offset to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke dash offset operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke dash offset operation.
     */
    set_stroke_dash_offset(stroke_dash_offset, recursive) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_set_stroke_dash_offset(ptr, stroke_dash_offset, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the stroke dash array of the VectorObjectBuilder.
     * @param {number[]} stroke_dash_array - The stroke dash array to set the vector object to.
     * @param {boolean | null} [recursive] - Whether to apply the set stroke dash array operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the set stroke dash array operation.
     */
    set_stroke_dash_array(stroke_dash_array, recursive) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayF32ToWasm0(stroke_dash_array, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_stroke_dash_array(ptr, ptr0, len0, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the children of the VectorObjectBuilder.
     * @param {VectorObjectBuilder[]} children - The children to set the vector object to.
     * @returns {VectorObjectBuilder} The vector object being built with the set children operation.
     */
    set_children(children) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(children, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_children(ptr, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the name of the VectorObjectBuilder.
     * @param {string | null} [name] - The name to set the vector object to.
     * @returns {VectorObjectBuilder} The vector object being built with the set name operation.
     */
    set_name(name) {
        const ptr = this.__destroy_into_raw();
        var ptr0 = isLikeNone(name) ? 0 : passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_name(ptr, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Adds a child to the VectorObjectBuilder.
     * @param {VectorObjectBuilder} child - The child to add to the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the add child operation.
     */
    add_child(child) {
        const ptr = this.__destroy_into_raw();
        _assertClass(child, VectorObjectBuilder);
        var ptr0 = child.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_add_child(ptr, ptr0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Removes all children with the given indices from the VectorObjectBuilder.
     * @param {number[]} indices - The indices of the children to remove from the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the remove children at indices operation.
     */
    remove_children_at_indices(indices) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_remove_children_at_indices(ptr, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Removes all children with the given names from the VectorObjectBuilder.
     * @param {string[]} names - The names of the children to remove from the vector object.
     * @returns {VectorObjectBuilder} The vector object being built with the remove children by names operation.
     */
    remove_children_by_names(names) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(names, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_remove_children_by_names(ptr, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Sets the children from the start index to the end index of the VectorObjectBuilder.
     * @param {number} start - The start index of the children to replace.
     * @param {number} end - The end index of the children to replace.
     * @param {VectorObjectBuilder[]} children - The children to replace the children from the start index to the end index with.
     * @returns {VectorObjectBuilder} The vector object being built with the set slice children operation.
     */
    set_slice_children(start, end, children) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(children, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vectorobjectbuilder_set_slice_children(ptr, start, end, ptr0, len0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Puts the VectorObjectBuilder next to the given Point2D at the given direction, with a buff distance between them and aligning at the given edge.
     * @param {Point2D} point - The point to translate the vector object to.
     * @param {Point2D | null} [direction] - The direction to translate the vector object in. If not given, the vector object will be at the right of the point, default is right.
     * @param {number | null} [buff] - The buffer to leave between the vector object and the point. If not given, the vector object will be touching the point, default is 0.
     * @param {Point2D | null} [aligned_edge] - The edge of the vector object to align with the point. If not given, the vector object will be aligned at the middle, default is the middle.
     * @param {boolean | null} [recursive] - Whether to apply the next to point operation to the children of the vector object. If not given, the operation will be applied to the children, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the next to point operation.
     */
    next_to_point(point, direction, buff, aligned_edge, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(point, Point2D);
        var ptr0 = point.__destroy_into_raw();
        let ptr1 = 0;
        if (!isLikeNone(direction)) {
            _assertClass(direction, Point2D);
            ptr1 = direction.__destroy_into_raw();
        }
        let ptr2 = 0;
        if (!isLikeNone(aligned_edge)) {
            _assertClass(aligned_edge, Point2D);
            ptr2 = aligned_edge.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_next_to_point(ptr, ptr0, ptr1, isLikeNone(buff) ? 0x100000001 : Math.fround(buff), ptr2, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Puts the VectorObjectBuilder next to the given VectorObjectBuilder at the given direction, with a buff distance between them and aligning at the given edge.
     * @param {VectorObjectBuilder} other - The other vector object to translate the vector object to.
     * @param {Point2D | null} [direction] - The direction to translate the vector object in. If not given, the vector object will be at the right of the other vector object, default is right.
     * @param {number | null} [buff] - The buffer to leave between the vector object and the other vector object. If not given, the vector object will be touching the other vector object, default is 0.
     * @param {Point2D | null} [aligned_edge] - The edge of the vector object to align with the other vector object. If not given, the vector object will be aligned at the middle, default is the middle.
     * @param {boolean | null} [recursive] - Whether to apply the next to other operation to the children of the vector object. If not given, the operation will be applied to the children, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the next to other operation.
     */
    next_to_other(other, direction, buff, aligned_edge, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(other, VectorObjectBuilder);
        var ptr0 = other.__destroy_into_raw();
        let ptr1 = 0;
        if (!isLikeNone(direction)) {
            _assertClass(direction, Point2D);
            ptr1 = direction.__destroy_into_raw();
        }
        let ptr2 = 0;
        if (!isLikeNone(aligned_edge)) {
            _assertClass(aligned_edge, Point2D);
            ptr2 = aligned_edge.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_next_to_other(ptr, ptr0, ptr1, isLikeNone(buff) ? 0x100000001 : Math.fround(buff), ptr2, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Arranges the children of the VectorObjectBuilder in the given direction, with a buff distance between them and aligning at the given edge.
     * @param {Point2D | null} [direction] - The direction to arrange the children. If not given, the children will be arranged horizontally in the positive x direction.
     * @param {number | null} [buff] - The buffer to leave between the children. If not given, the children will be touching, default is 0.
     * @param {Point2D | null} [aligned_edge] - The edge of the children to align with the point. If not given, the children will be aligned at the middle.
     * @param {Point2D | null} [center] - The center of the children. If not given, the children won't be centered at any point.
     * @param {boolean | null} [recursive] - Whether to apply the arrange subobjects operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the arrange subobjects operation.
     */
    arrange_children(direction, buff, aligned_edge, center, recursive) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(direction)) {
            _assertClass(direction, Point2D);
            ptr0 = direction.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(aligned_edge)) {
            _assertClass(aligned_edge, Point2D);
            ptr1 = aligned_edge.__destroy_into_raw();
        }
        let ptr2 = 0;
        if (!isLikeNone(center)) {
            _assertClass(center, Point2D);
            ptr2 = center.__destroy_into_raw();
        }
        const ret = wasm.vectorobjectbuilder_arrange_children(ptr, ptr0, isLikeNone(buff) ? 0x100000001 : Math.fround(buff), ptr1, ptr2, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Reverses the path of the VectorObjectBuilder.
     * @returns {VectorObjectBuilder} The vector object being built with the reverse path operation.
     */
    reverse_path() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_reverse_path(ptr);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Linearly interpolates the fill Style of the VectorObjectBuilder with another VectorObjectBuilder.
     * @param {Style} fill - The vector object to interpolate the fill style with.
     * @param {number} t - The factor to interpolate the fill style by.
     * @param {boolean | null} [recursive] - Whether to apply the interpolate fill operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the interpolate fill operation.
     */
    lerp_fill(fill, t, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(fill, Style);
        var ptr0 = fill.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_lerp_fill(ptr, ptr0, t, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Linearly interpolates the stroke Style of the VectorObjectBuilder with another VectorObjectBuilder.
     * @param {Style} stroke - The vector object to interpolate the stroke style with.
     * @param {number} t - The factor to interpolate the stroke style by.
     * @param {boolean | null} [recursive] - Whether to apply the interpolate stroke operation to the children of the vector object, default is true.
     * @returns {VectorObjectBuilder} The vector object being built with the interpolate stroke operation.
     */
    lerp_stroke(stroke, t, recursive) {
        const ptr = this.__destroy_into_raw();
        _assertClass(stroke, Style);
        var ptr0 = stroke.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_lerp_stroke(ptr, ptr0, t, isLikeNone(recursive) ? 0xFFFFFF : recursive ? 1 : 0);
        return VectorObjectBuilder.__wrap(ret);
    }
    /**
     * Builds the VectorObject by applying sequentially all the operations to the VectorObjectBuilder.
     * @returns {VectorObject} The vector object built by applying the operations to it.
     */
    build() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.vectorobjectbuilder_build(ptr);
        return VectorObject.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' &amp;&amp; module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_colorstop_new = function(arg0) {
        const ret = ColorStop.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_colorstop_unwrap = function(arg0) {
        const ret = ColorStop.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_cubicbeziertuple_new = function(arg0) {
        const ret = CubicBezierTuple.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_fontface_unwrap = function(arg0) {
        const ret = FontFace.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_getTime_46267b1c24877e30 = function(arg0) {
        const ret = arg0.getTime();
        return ret;
    };
    imports.wbg.__wbg_log_5c4af1b4abeb2c77 = function(arg0, arg1) {
        console.log(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbg_new0_f788a2397c7ca929 = function() {
        const ret = new Date();
        return ret;
    };
    imports.wbg.__wbg_path2d_new = function(arg0) {
        const ret = Path2D.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_point2d_new = function(arg0) {
        const ret = Point2D.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_point2d_unwrap = function(arg0) {
        const ret = Point2D.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_vectorobject_new = function(arg0) {
        const ret = VectorObject.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_vectorobject_unwrap = function(arg0) {
        const ret = VectorObject.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_vectorobjectbuilder_unwrap = function(arg0) {
        const ret = VectorObjectBuilder.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        const ret = debugString(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm.__wbindgen_export_2;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
        ;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_init_memory(imports, memory) {

}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedFloat32ArrayMemory0 = null;
    cachedUint32ArrayMemory0 = null;
    cachedUint8ArrayMemory0 = null;


    wasm.__wbindgen_start();
    return wasm;
}

function initSync(module) {
    if (wasm !== undefined) return wasm;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module)
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')
        }
    }

    const imports = __wbg_get_imports();

    __wbg_init_memory(imports);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm !== undefined) return wasm;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path)
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead')
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL('index_bg.wasm', import.meta.url);
    }
    const imports = __wbg_get_imports();

    if (typeof module_or_path === 'string' || (typeof Request === 'function' &amp;&amp; module_or_path instanceof Request) || (typeof URL === 'function' &amp;&amp; module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    __wbg_init_memory(imports);

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

export { initSync };
export default __wbg_init;
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="AnchorsAndHandles.html">AnchorsAndHandles</a></div><div class="sidebar-section-children"><a href="Arc.html">Arc</a></div><div class="sidebar-section-children"><a href="BoundingBox.html">BoundingBox</a></div><div class="sidebar-section-children"><a href="Circle.html">Circle</a></div><div class="sidebar-section-children"><a href="Color.html">Color</a></div><div class="sidebar-section-children"><a href="ColorStop.html">ColorStop</a></div><div class="sidebar-section-children"><a href="CubicBezierTuple.html">CubicBezierTuple</a></div><div class="sidebar-section-children"><a href="EquilateralTriangle.html">EquilateralTriangle</a></div><div class="sidebar-section-children"><a href="FontFace.html">FontFace</a></div><div class="sidebar-section-children"><a href="ImageBitmap.html">ImageBitmap</a></div><div class="sidebar-section-children"><a href="IntegerLerp.html">IntegerLerp</a></div><div class="sidebar-section-children"><a href="Line.html">Line</a></div><div class="sidebar-section-children"><a href="LinearGradient.html">LinearGradient</a></div><div class="sidebar-section-children"><a href="Path2D.html">Path2D</a></div><div class="sidebar-section-children"><a href="Point2D.html">Point2D</a></div><div class="sidebar-section-children"><a href="RadialGradient.html">RadialGradient</a></div><div class="sidebar-section-children"><a href="Rectangle.html">Rectangle</a></div><div class="sidebar-section-children"><a href="RightTriangle.html">RightTriangle</a></div><div class="sidebar-section-children"><a href="Square.html">Square</a></div><div class="sidebar-section-children"><a href="Style.html">Style</a></div><div class="sidebar-section-children"><a href="TransformationMatrix.html">TransformationMatrix</a></div><div class="sidebar-section-children"><a href="Triangle.html">Triangle</a></div><div class="sidebar-section-children"><a href="Typst.html">Typst</a></div><div class="sidebar-section-children"><a href="VectorObject.html">VectorObject</a></div><div class="sidebar-section-children"><a href="VectorObjectBuilder.html">VectorObjectBuilder</a></div><div class="sidebar-section-children"><a href="module.exports.html">exports</a></div><div class="sidebar-section-children"><a href="module.exports.html">exports</a></div><div class="sidebar-section-children"><a href="module.exports.html">exports</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-tutorials"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-Initial tutorials.html">Initial tutorials</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#inverse_lerp">inverse_lerp</a></div><div class="sidebar-section-children"><a href="global.html#lerp">lerp</a></div><div class="sidebar-section-children"><a href="global.html#matrix_product">matrix_product</a></div><div class="sidebar-section-children"><a href="global.html#matrix_product_path">matrix_product_path</a></div><div class="sidebar-section-children"><a href="global.html#play">play</a></div><div class="sidebar-section-children"><a href="global.html#render">render</a></div><div class="sidebar-section-children"><a href="global.html#render">render</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>